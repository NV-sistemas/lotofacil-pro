<!DOCTYPE html>.
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Lotof√°cil Prime Analytics</title>

<style>
  :root{
    /* ‚úÖ PADR√ÉO PRETO + AMARELO (igual ao sistema de vendas) */
    --bg1:#000000; --bg2:#000000;

    /* Cards / superf√≠cies (sempre preto) */
    --card:#000000;

    /* Preto fosco (cards/bot√µes) */
    --surface: rgba(255,255,255,.06);
    --surface2: rgba(255,255,255,.08); 
    --text:#ffffff;
    --muted: rgba(255,255,255,.82);
    --muted2: rgba(255,255,255,.70);

    /* Cor destaque (amarelo) */
    --accent:#facc15;
    --accent2:#ffd84d;

    /* Mant√©m vari√°veis antigas por compatibilidade, mas SEM VERDE */
    --green:#facc15; --green2:#ffd84d;
    --blue:#facc15; --blue2:#ffd84d;
    --purple:#facc15; --purple2:#ffd84d;
    --yellow:#facc15; --orange:#fb923c;
    --red:#fb7185; --red2:#ef4444;

    --stroke: rgba(255,255,255,.35);
    --stroke2: rgba(255,255,255,.28);
    --shadow: 0 22px 70px rgba(0,0,0,.65);

    /* Glows (sem verde) */
    --glowBlue: 0 0 0 1px rgba(250,204,21,.22), 0 12px 40px rgba(250,204,21,.12);
    --glowGreen: 0 0 0 1px rgba(250,204,21,.22), 0 12px 40px rgba(250,204,21,.12);
    --glowGold: 0 0 0 1px rgba(250,204,21,.22), 0 18px 60px rgba(250,204,21,.18);
  }

*{box-sizing:border-box;font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif}
  html,body{height:100%}
  body{
    margin:0;color:var(--text);
    background:
      radial-gradient(900px 650px at 15% 10%, rgba(250,204,21,.10), transparent 58%),
      radial-gradient(900px 650px at 85% 15%, rgba(251,146,60,.06), transparent 60%),
      linear-gradient(180deg,var(--bg1),var(--bg2));
    min-height:100dvh;
    overflow-x:hidden; /* ‚úÖ evita "torto" no mobile */
  }

  .center{
    display:flex;align-items:center;justify-content:center;
    min-height:100dvh;padding:16px;
  }
  .wrap{max-width:1180px;margin:0 auto;padding:18px}

  /* Header */
  .header{display:flex;justify-content:center;align-items:center;margin-bottom:14px}
  .title{
    font-size: clamp(20px, 5.6vw, 28px);
    font-weight:1000;margin:0;letter-spacing:.2px;text-align:center;
    line-height:1.15;
    color: var(--accent);
  }

  /* Chip (status) */
  .chip{
    display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:999px;
    background: rgba(0,0,0,.72);
    border:1px solid var(--stroke);
    color:var(--text);
    font-size:12px;font-weight:900;
    box-shadow: 0 10px 30px rgba(0,0,0,.25);
    white-space:nowrap;
  }
  .chip .dot{width:7px;height:7px;border-radius:999px;background:rgba(250,204,21,.95);display:inline-block}

  .card{
    background: var(--surface);
    border:1px solid var(--stroke);
    border-radius:20px;padding:16px;
    box-shadow:var(--shadow);
    margin-bottom:14px;
    backdrop-filter: blur(10px);
    width:100%;
    max-width: 520px; /* ‚úÖ login alinhado no celular */
    margin-left:auto;margin-right:auto;
  }

  /* Cards do APP (n√£o limitar largura) */
  #app .card{max-width:none}

  .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:12px;margin-top:12px}
  .gridExplain{grid-template-columns:repeat(auto-fit,minmax(320px,1fr));}
  .box{
    background: var(--surface);
    border:1px solid var(--stroke);
    border-radius:16px;padding:12px;
  }
  
  /* ‚úÖ JOGOS SALVOS: item selecionado no padr√£o AMARELO (igual Print 1) */
  .savedPack.on{
    background: rgba(250,204,21,.18) !important;
    border-color: rgba(250,204,21,.75) !important;
    color:#0b0b0b !important;
  }
  .savedPack.on b{ color:#0b0b0b !important; }
  .savedPack.on .mini{ color: rgba(0,0,0,.72) !important; }

.box p{margin:0;color:var(--text);font-size:13px;line-height:1.5}
  .mini{color:var(--muted);font-size:12px;margin-top:8px;line-height:1.45}
  .mini strong{color:var(--text)}

  .row{display:flex;gap:12px;flex-wrap:wrap;align-items:stretch}
  .col{flex:1 1 240px;min-width:0} /* ‚úÖ evita ‚Äútorto‚Äù */

  label{display:block;font-size:12px;color:var(--accent);font-weight:950;margin-bottom:6px;text-align:left}
  input, select{
    width:100%;max-width:100%;
    padding:13px 12px;border-radius:14px;border:1px solid var(--stroke2);
    background: rgba(0,0,0,.78);
    color:var(--text);outline:none;
  }
  input::placeholder{color:rgba(203,213,225,.65)}
  select{cursor:pointer}

  .btn{
    padding:12px 14px;
    border:1px solid var(--stroke);
    border-radius:14px;
    background: var(--surface);
    color: var(--text);
    font-weight:1000;
    cursor:pointer;
    transition:.15s;
    box-shadow: 0 18px 45px rgba(0,0,0,.35);
    width:100%;
  }
  .btn:hover{filter:brightness(1.05);transform:translateY(-1px)}
  .btn:active{transform:translateY(0px);filter:brightness(.98)}
  .btn:disabled{opacity:.55;cursor:not-allowed;transform:none;box-shadow:none}
  .btnPrimary{background:linear-gradient(135deg,var(--yellow),var(--yellow2));box-shadow: var(--glowGold);color:#111111;border:1px solid rgba(250,204,21,.55)}
  .btnBlue{background:linear-gradient(135deg,var(--accent),var(--accent2));box-shadow: var(--glowGold);color:#111111;border:1px solid rgba(255,255,255,.28)}
  .btnPurple{background:linear-gradient(135deg,var(--accent),var(--accent2));color:#111111;box-shadow: var(--glowGold);border:1px solid rgba(255,255,255,.28)}
  .btnDanger{background:linear-gradient(135deg,var(--red),var(--red2));color:#2b0b0b;box-shadow: 0 0 0 1px rgba(251,113,133,.18), 0 12px 40px rgba(251,113,133,.12)}
  .btnGhost{
    background: rgba(0,0,0,.70);
    border:1px solid rgba(255,255,255,.14);
    color:var(--text);
    box-shadow:none;
    width:auto;
  }

  .status{display:none;margin-top:10px;padding:12px;border-radius:14px;background:rgba(56,189,248,.10);
          border:1px solid rgba(56,189,248,.22);color:#e6f8ff;font-size:13px;font-weight:950;}
  .bar{height:10px;border-radius:999px;overflow:hidden;background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.08);margin-top:10px}
  .bar>div{height:100%;width:0%;background:linear-gradient(90deg,var(--accent),var(--orange));transition:width .2s ease}

  /* Views */
  .view{display:none}
  .view.on{display:block}
  .topNav{
    display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
    margin-bottom:10px;
  }
  .topNav .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .topNav .right{display:flex;gap:10px;flex-wrap:wrap;align-items:center}

  /* Op√ß√µes */
  .actionGrid{display:grid;grid-template-columns:repeat(auto-fit,minmax(280px,1fr));gap:14px;margin-top:12px}
  .actionCard{
    text-align:left;border:1px solid var(--stroke);
    background: var(--surface);
    border-radius:20px;padding:18px 18px;
    cursor:pointer;transition:.15s;
    position:relative;min-height:126px;
    box-shadow: 0 18px 55px rgba(0,0,0,.38);
  }
  .actionCard:hover{transform:translateY(-2px);background: var(--surface2);}
  .actionTitle{font-weight:1000;font-size:16px;margin:0 0 8px;color: var(--yellow);}
  .actionDesc{margin:0;color: rgba(255,255,255,.88);font-size:13px;line-height:1.55}
  /* ‚úÖ T√≠tulo amarelo dentro dos cards (padr√£o vendas) */
  .actionCard b, .actionCard strong{color: var(--yellow)}


  .badge{
    position:absolute;top:14px;right:14px;
    font-size:11px;font-weight:1000;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.72);
    color:var(--text);
  }
  .badge.premium{border-color:rgba(56,189,248,.30);background:rgba(56,189,248,.14);color:#e6f8ff}
  .badge.free{border-color:rgba(250,204,21,.35);background:rgba(250,204,21,.14);color:#fff2b0}

  /* EXTRA mega chamativo */
  .extraCard{
    border:1px solid rgba(250,204,21,.35);
    background: radial-gradient(900px 240px at 30% 20%, rgba(250,204,21,.14), transparent 60%),
                radial-gradient(900px 240px at 70% 20%, rgba(251,146,60,.10), transparent 60%),
                rgba(0,0,0,.82);
    box-shadow: var(--glowGold), 0 22px 70px rgba(0,0,0,.45);
    transform: translateZ(0);
  }
  .extraBadge{
    position:absolute;top:14px;right:14px;
    font-size:11px;font-weight:1000;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(250,204,21,.35);
    background:rgba(250,204,21,.18);
    color:#fff2b0;
  }
  .extraHeadline{
    display:flex;align-items:center;gap:10px;flex-wrap:wrap;
    margin-bottom:6px
  }
  .extraHighlight{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border-radius:999px;
    border:1px solid rgba(250,204,21,.35);
    background:rgba(250,204,21,.14);
    color:#fff2b0;
    font-weight:1000;font-size:12px;
  }

  /* Cart√£o Lotof√°cil (5x5) */
  .cartaoWrap{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px}
  /* ‚úÖ MOBILE: ajustes extras (apenas no celular) */
@media (max-width: 520px){
  .actionGrid{ grid-template-columns: 1fr; }
  .header{ margin-bottom: 10px; }
}

  .cartao{
    display:grid;grid-template-columns: repeat(5, 44px);
    gap:8px;justify-content:center;margin:10px 0 0;
  }
  .cel{
    width:44px;height:44px;border-radius:12px;
    display:flex;align-items:center;justify-content:center;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.70);
    color:var(--text);font-weight:1000;
  }
  .cel.on{background:rgba(0,0,0,.72);border:1px solid rgba(250,204,21,.38);color:var(--accent);box-shadow:0 12px 30px rgba(0,0,0,.25)}
  .cel.inv{background:rgba(0,0,0,.72);border:1px solid rgba(250,204,21,.28);color:var(--accent2);box-shadow:0 12px 30px rgba(0,0,0,.25)}
  .cel.tech{background:rgba(250,204,21,.14);border:1px solid rgba(250,204,21,.30);color:#fff2b0;box-shadow:0 12px 30px rgba(0,0,0,.25)}

  .numbers{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin:10px 0 6px}
  .ball{
    width:44px;height:44px;border-radius:999px;display:flex;align-items:center;justify-content:center;
    background:rgba(0,0,0,.72);
    border:1px solid rgba(250,204,21,.28);
    color:var(--accent);font-weight:1000;letter-spacing:.4px;
    box-shadow:0 14px 34px rgba(0,0,0,.35);
  }
  .hr{height:1px;background:rgba(255,255,255,.10);margin:12px 0;border-radius:999px}

  /* Painel ‚Äúverificar jogos gerados‚Äù */
  .panelCheck{
    margin-top:12px;
    border:1px solid var(--stroke);
    background: var(--surface);
    border-radius:18px;
    padding:14px;
  }
  .panelCheck b{font-size:13px}

  /* Modal */
  .modalBack{display:none;position:fixed;inset:0;background:rgba(0,0,0,.62);backdrop-filter: blur(7px);
             align-items:center;justify-content:center;padding:16px;z-index:999}
  .modal{width:100%;max-width:980px;background:linear-gradient(180deg,var(--card),rgba(255,255,255,.03));
         border:1px solid rgba(255,255,255,.12);border-radius:20px;box-shadow:0 40px 120px rgba(0,0,0,.70);
         overflow:hidden}
  .modalHeader{display:flex;justify-content:space-between;align-items:center;padding:14px 16px;border-bottom:1px solid rgba(255,255,255,.10)}
  .modalHeader b{font-size:14px}
  .closeBtn{padding:9px 11px;border-radius:12px;background: rgba(0,0,0,.70);border:1px solid rgba(255,255,255,.14);
            color:var(--text);cursor:pointer;font-weight:900}
  .modalBody{padding:14px 16px}

  .table{width:100%;border-collapse:collapse;font-size:13px}
  .table th,.table td{padding:10px 8px;border-bottom:1px solid rgba(255,255,255,.10);text-align:left;vertical-align:top}
  .table th{color:var(--muted);font-weight:1000;font-size:12px}
  .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  .footerNote{text-align:center;color:var(--muted2);font-size:11px;margin-top:10px}

  /* Rodap√© do app (chip centralizado) */
  .appFooter{margin-top:8px;display:flex;justify-content:center;}

  /* Rodap√© da tela 15p (fonte + modo) */
  .tinyFoot{margin-top:12px;text-align:center;color:rgba(203,213,225,.75);font-size:11px;}

  /* ‚úÖ Tooltip */
  .tip{
    position:relative;
    display:inline-flex;
    align-items:center;
    gap:6px;
    cursor:help;
    border-bottom:1px dashed rgba(203,213,225,.45);
  }
  .tip::after{
    content: attr(data-tip);
    position:absolute;
    left:0;
    top: calc(100% + 8px);
    min-width: 220px;
    max-width: 360px;
    padding:10px 12px;
    border-radius:12px;
    background:rgba(2,6,23,.92);
    border:1px solid rgba(255,255,255,.14);
    color:rgba(248,250,252,.95);
    box-shadow: 0 18px 55px rgba(0,0,0,.55);
    opacity:0;
    pointer-events:none;
    transform: translateY(-4px);
    transition: .12s ease;
    z-index: 9999;
    font-size: 12px;
    line-height: 1.35;
    white-space: normal;
  }
  .tip:hover::after{ opacity:1; transform: translateY(0); }
  .tip .q{opacity:.8}

  /* ‚úÖ Fix mobile geral */
  /* ‚úÖ FIX ANDROID: remove o "buraco" no login quando vira coluna */
@media (max-width: 520px){
  #loginWrap .row{
    flex-direction: column;
    gap: 10px;
  }
  #loginWrap .col{
    flex: 1 1 auto !important;
  }
}

/* ===== MANUAL PICK (principal + 15P) ===== */
.pickGrid{display:grid;grid-template-columns:repeat(5,1fr);gap:8px;max-width:460px;margin-top:10px}
.pickCell{
  height:44px;border-radius:12px;
  display:flex;align-items:center;justify-content:center;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.70);
  font-weight:1000;cursor:pointer;user-select:none;
}
.pickCell.sel{background:rgba(0,0,0,.72);border-color:rgba(250,204,21,.40);color:var(--accent);box-shadow:0 12px 30px rgba(0,0,0,.25)}
.pickCell.lock{opacity:.35;cursor:not-allowed}
/* =========================
   ‚úÖ Destaque de acertos (Jogos Salvos)
   11,12,13,14,15 com cor
========================= */
.hit-11{ color:#38bdf8; font-weight:900; }  /* azul */
.hit-12{ color:#a78bfa; font-weight:900; }  /* roxo */
.hit-13{ color:#facc15; font-weight:1000; } /* amarelo */
.hit-14{ color:#fb923c; font-weight:1000; } /* laranja */
.hit-15{ color:#facc15; font-weight:1000; } /* amarelo */

.lineTabs{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
.lineBtn{
  padding:8px 10px;border-radius:12px;
  border:1px solid rgba(255,255,255,.14);
  background: rgba(0,0,0,.70);
  color:var(--text);font-weight:1000;cursor:pointer
}
.lineBtn.on{border-color:rgba(56,189,248,.35);background:rgba(56,189,248,.12);color:#e6f8ff}
.slotRow{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
.slot{
  min-width:52px;
  padding:8px 10px;border-radius:12px;
  border:1px dashed rgba(255,255,255,.18);
  background: rgba(0,0,0,.66);
  font-weight:1000;
}

  /* ‚úÖ BOT√ïES: preto fosco + destaque e PRIMARY sempre amarelo (igual Print 1) */
  .btnPrimary{
    background: var(--yellow) !important;
    color:#111111 !important;
    border:1px solid rgba(250,204,21,.80) !important;
    box-shadow: var(--glowGold) !important;
  }

  /* ‚úÖ MOBILE: evita quebra feia das 5 bolas nas linhas 4/5 do 15P */
  @media (max-width:420px){
    .ball{ width:38px; height:38px; font-size:13px; }
    .numbers{ gap:6px; }
  }

  /* ‚úÖ Ilustra√ß√£o de troca de COLUNAS (Invertida/T√©cnica) */
  .swapCard{ margin-top: 10px; }
  .swapImgs{
    display:grid;
    grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    gap:12px;
    margin-top:12px;
    align-items:start;
  }
  .swapImgWrap{
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.66);
    border-radius:16px;
    padding:12px;
    text-align:center;
    overflow:visible;
  }
  .swapImgWrap b{ color: var(--yellow); display:block; margin-bottom:8px; }
  .swapImg{
    display:block;
    width:100%;
    max-width: 520px;
    height:auto;
    aspect-ratio: 5 / 6;
    object-fit: contain;
    margin: 0 auto;
    border-radius:14px;
    border:1px solid rgba(250,204,21,.22);
    background: rgba(0,0,0,.70);
    box-shadow: 0 18px 55px rgba(0,0,0,.38);
  }
  .swapRow{ display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
  .swapMini{
    flex: 1 1 260px;
    border:1px solid rgba(255,255,255,.14);
    background: rgba(0,0,0,.66);
    border-radius:16px;
    padding:12px;
  }
  .swapMini b{ color: var(--yellow); }
  .swapGamesRow{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap:12px;
    margin-top:12px;
    align-items:start;
  }
  @media (max-width: 900px){
    .swapGamesRow{ grid-template-columns: 1fr; }
  }

</style>
</head>

<body>

<!-- ================= FIREBASE SDKs (HTML PURO) ================= -->
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-functions-compat.js"></script>

<script>
/* =========================
   CONFIG
========================= */
const APP_NAME = "LOTOF√ÅCIL PRIME ANALYTICS";
const BUY_LINK = "https://pay.hotmart.com/O104148865Y?off=c4m0nezi";
const BUY_LINK_15P = "https://pay.hotmart.com/Y104149008G?off=eehchnv4";

/* ‚úÖ Admin sempre com tudo (no front s√≥ para UI; o correto √© garantir via claims no backend) */
const ADMIN_EMAIL = "admin@lotofacilprime.com";

/* ‚úÖ Limite Free (1x) por usu√°rio */
function freeKey(uid){ return `lf_free_used_v1_${uid||"anon"}`; }
/* =========================
   ‚úÖ NOVA SEQU√äNCIA 8/9/10 (20% / 50% / 30%)
   A cada 10 jogos: 2 ser√£o de 8, 5 ser√£o de 9, 3 ser√£o de 10.
   (sequ√™ncia fixa, sem aleat√≥rio)
========================= */
const PRINCIPAL_SEQ_KEY = "lf_principal_seq_v1";

/* Sequ√™ncia fixa (10 posi√ß√µes) -> 2x8, 5x9, 3x10 */
const PRINCIPAL_SEQ = [9, 8, 9, 10, 9, 8, 9, 10, 9, 10];

function getNextPrincipalBaseSize(){
  let n = Number(localStorage.getItem(PRINCIPAL_SEQ_KEY) || "0");
  const k = PRINCIPAL_SEQ[n % PRINCIPAL_SEQ.length];
  localStorage.setItem(PRINCIPAL_SEQ_KEY, String(n + 1));
  return k; // 8, 9 ou 10
}
</script>

<script>
/* ================= FIREBASE CONFIG (SEU) ================= */
const firebaseConfig = {
  apiKey: "AIzaSyCodYgkQG0TUaqCk1i-0QcSB8GIt0iWp8c",
  authDomain: "lotofacil-prime.firebaseapp.com",
  projectId: "lotofacil-prime",
  storageBucket: "lotofacil-prime.firebasestorage.app",
  messagingSenderId: "385524602679",
  appId: "1:385524602679:web:9760aeb30dcb835a962cb2"
};

firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const functions = firebase.app().functions("us-central1");
</script>

<!-- LOGIN -->
<div class="center" id="loginWrap">
  <div class="card">
    <div style="text-align:center">
      <div class="title" style="margin:0">üéØ <span id="appName1"></span></div>
      <div class="mini" style="margin-top:6px">
        Entre para acessar o painel. Premium libera as ferramentas principais.
      </div>
    </div>

    <div style="margin-top:12px" class="row">
      <div class="col">
        <label>Email</label>
        <input id="email" type="email" placeholder="seuemail@gmail.com" />
      </div>
      <div class="col">
        <label>Senha</label>
        <input id="senha" type="password" placeholder="sua senha" />
      </div>
    </div>

    <button id="btnEntrar" class="btn btnPrimary" type="button">Entrar / Criar conta</button>

    <button id="btnForgot" class="btn" type="button" style="margin-top:10px;background: rgba(0,0,0,.72);border:1px solid rgba(255,255,255,.14);color:var(--text);box-shadow:none">
      Esqueci minha senha
    </button>

    <div id="msgOk" class="status" style="display:none"></div>
    <div id="msgErr" class="status" style="display:none;background:rgba(251,113,133,.12);border:1px solid rgba(251,113,133,.28);color:#ffe7ec"></div>

    <div class="footerNote">Dica: use o mesmo email utilizado na compra Hotmart.</div>
  </div>
</div>

<!-- APP -->
<div class="wrap" id="app" style="display:none">
  <div class="header">
    <div class="title">üéØ <span id="appName2"></span></div>
  </div>

  <!-- PREMIUM GATE -->
  <div class="card" id="premiumGate" style="display:none">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
      <div>
        <div style="font-weight:1000;font-size:16px">üîí √Årea Premium</div>
        <div class="mini">
          No modo Free voc√™ pode gerar <b>1 vez</b> apenas no <b>Jogo Principal</b>.
          Para liberar <b>An√°lise</b>, <b>Invertida</b> e <b>T√©cnica Premiada</b>, ative o Premium.
        </div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap">
        <button class="btn btnDanger" id="btnComprar" type="button">Comprar Premium</button>
        <button class="btn btnGhost" id="btnJaComprei" type="button">J√° comprei</button>
        <button class="btn btnGhost" id="btnSair" type="button">Sair</button>
      </div>
    </div>
  </div>

  <!-- EXTRA 15P UPSELL -->
  <div class="card" id="addon15Card" style="display:none">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap">
      <div>
        <div style="font-weight:1000;font-size:16px">‚ú® Recurso Extra: 15 pontos garantido</div>
        <div class="mini">
          Esse recurso √© um <b>EXTRA comprado separadamente</b> e abre uma tela pr√≥pria.
        </div>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <button class="btn btnDanger" id="btnComprar15p" type="button">Comprar 15 pontos</button>
        <button class="btn btnGhost" id="btnAtivar15p" type="button">J√° comprei</button>
      </div>
    </div>
  </div>

      <!-- ===== TELAS ===== -->
  <div class="view on" id="viewHome">
    <div class="card">

      <!-- Linha superior: seletor + progresso -->
      <div class="row">
        <div class="col">
          <label>Quantidade de concursos para analisar</label>
          <select id="qtdConcursos">
            <option value="3">3 concursos</option>
            <option value="4">4 concursos</option>
            <option value="5">5 concursos</option>
            <option value="6">6 concursos</option>
            <option value="12">12 concursos</option>
            <option value="15">15 concursos</option>
            <option value="20" selected>20 concursos</option>
            <option value="30">30 concursos</option>
            <option value="50">50 concursos</option>
            <option value="75">75 concursos</option>
            <option value="100">100 concursos</option>
           </select>

          <div class="mini" style="margin-top:8px">
            Escolha a janela e depois selecione uma das op√ß√µes abaixo.
          </div>
        </div>

        <div class="col">
          <label>Progresso</label>

          <div id="status" class="status">
            <div id="statusText">Carregando‚Ä¶</div>
            <div class="bar"><div id="barFill"></div></div>
          </div>

          <div class="mini">
            Se a an√°lise estiver pesada, use 10 ou 20 concursos.
          </div>
        </div>
      </div>

      <div class="hr"></div>

      <!-- Cards de a√ß√µes -->
      <div class="actionGrid">
        <!-- FREE -->
        <div class="actionCard" id="btnHomePrincipal" role="button" tabindex="0">
          <span class="badge free">FREE 1x</span>
          <p class="actionTitle">üéØ Jogo principal</p>
          <p class="actionDesc">Gera 15 dezenas + resumo PRIME. Voc√™ tamb√©m pode montar o seu jogo manualmente.</p>
        </div>

        <!-- PREMIUM -->
        <div class="actionCard" id="btnHomeAnalise" role="button" tabindex="0">
          <span class="badge premium">PREMIUM</span>
          <p class="actionTitle">üìà Gerar an√°lise</p>
          <p class="actionDesc">Resumo PRIME do per√≠odo selecionado (sem jogo) com tend√™ncias e probabilidades.</p>
        </div>

        <div class="actionCard" id="btnHomeInvertida" role="button" tabindex="0">
          <span class="badge premium">PREMIUM</span>
          <p class="actionTitle">üîÑ Gerar invertida</p>
          <p class="actionDesc">Usa o Jogo Principal (autom√°tico ou manual) e inverte por blocos no cart√£o 5√ó5.</p>
        </div>

        <div class="actionCard" id="btnHomeTecnica" role="button" tabindex="0">
          <span class="badge premium">PREMIUM</span>
          <p class="actionTitle">üèÜ T√©cnica premiada</p>
          <p class="actionDesc">Gera 2 jogos extras a partir do Principal (reordena√ß√£o por blocos).</p>
        </div>

        <!-- ‚úÖ JOGOS SALVOS (ANTES DO EXTRA) -->
        <div class="actionCard" id="btnHomeSaved" role="button" tabindex="0">
          <span class="badge premium">PREMIUM</span>
          <p class="actionTitle">üíæ Jogos salvos</p>
          <p class="actionDesc">
            Confira seus jogos salvos e veja quantos pontos faria nos √∫ltimos 5, 10, 20 ou 30 concursos.
          </p>
        </div>

        <!-- EXTRA (SEMPRE POR √öLTIMO) -->
        <div class="actionCard extraCard" id="btnHome15p" role="button" tabindex="0">
          <span class="extraBadge">EXTRA</span>
          <div class="extraHeadline">
            <p class="actionTitle" style="margin:0">‚úÖ 15 pontos garantido</p>
            <span class="extraHighlight">ESTRAT√âGIA (10 JOGOS)</span>
          </div>
          <p class="actionDesc">Tela separada: 5 linhas + an√°lise avan√ßada e 10 jogos. Voc√™ tamb√©m pode criar suas pr√≥prias linhas.</p>
        </div>
      </div>
    </div>

    <div class="card" id="resultadoHome">
      <div class="footerNote">Selecione a janela e escolha uma op√ß√£o acima.</div>
    </div>

    <div class="appFooter">
      <div class="chip" id="chipUser">
        <span class="dot"></span>
        <span id="chipText">‚Äî</span>
      </div>
    </div>
  </div>

  <!-- TELA: AN√ÅLISE -->
  <div class="view" id="viewAnalise">
    <div class="topNav">
      <div class="left">
        <button class="btn btnGhost" type="button" onclick="goView('viewHome')">‚¨Ö Voltar</button>
      </div>
      <div class="right">
        <button class="btn btnGhost" type="button" onclick="verConcursos()">üìÖ Ver concursos</button>
      </div>
    </div>

    <div class="card" id="analiseArea">
      <div class="footerNote">Clique em ‚ÄúGerar an√°lise‚Äù na tela principal.</div>
    </div>
  </div>

  <!-- TELA: JOGO PRINCIPAL -->
  <div class="view" id="viewPrincipal">
    <div class="topNav">
      <div class="left">
        <button class="btn btnGhost" type="button" onclick="goView('viewHome')">‚¨Ö Voltar</button>
      </div>
      <div class="right">
        <button class="btn btnBlue" type="button" onclick="goView('viewInvertida'); gerarInvertida()">üîÑ Invertida</button>
        <button class="btn btnPurple" type="button" onclick="goView('viewTecnica'); gerarTecnicaPremiada()">üèÜ T√©cnica</button>
        <button class="btn btnGhost" id="btnVerificarGeradosFromPrincipal" type="button" style="display:none" onclick="goView('viewCheck')">‚úÖ Verificar jogos gerados</button>
      </div>
    </div>

    <div class="card" id="principalArea">
      <div class="footerNote">Clique em ‚ÄúJogo Principal‚Äù na tela principal.</div>
    </div>
  </div>

  <!-- TELA: INVERTIDA -->
  <div class="view" id="viewInvertida">
    <div class="topNav">
      <div class="left">
        <button class="btn btnGhost" type="button" onclick="goView('viewPrincipal')">‚¨Ö Voltar</button>
      </div>
      <div class="right">
        <button class="btn btnPurple" type="button" onclick="goView('viewTecnica'); gerarTecnicaPremiada()">üèÜ Ir para T√©cnica</button>
      </div>
    </div>

    <div class="card" id="invertidaArea">
      <div class="footerNote">Gere um Jogo Principal primeiro.</div>
    </div>
  </div>

  <!-- TELA: T√âCNICA PREMIADA -->
  <div class="view" id="viewTecnica">
    <div class="topNav">
      <div class="left">
        <button class="btn btnGhost" type="button" onclick="goView('viewPrincipal')">‚¨Ö Voltar</button>
      </div>
      <div class="right">
        <button class="btn btnBlue" type="button" onclick="goView('viewInvertida'); gerarInvertida()">üîÑ Ir para Invertida</button>
      </div>
    </div>

    <div class="card" id="tecnicaArea">
      <div class="footerNote">Gere um Jogo Principal primeiro.</div>
    </div>
  </div>

  <!-- TELA: CHECK -->
  <div class="view" id="viewCheck">
    <div class="topNav">
      <div class="left">
        <button class="btn btnGhost" type="button" onclick="goView('viewPrincipal')">‚¨Ö Voltar</button>
      </div>
      <div class="right">
        <button class="btn btnGhost" type="button" onclick="conferirGerados()">Conferir com √∫ltimo concurso</button>
      </div>
    </div>

    <div class="card" id="checkArea">
      <div class="footerNote">Gere Principal + Invertida + T√©cnica para liberar esta tela.</div>
    </div>
  </div>

  <!-- TELA: 15 PONTOS -->
  <div class="view" id="view15p">
    <div class="topNav">
      <div class="left">
        <button class="btn btnGhost" type="button" onclick="goView('viewHome')">‚¨Ö Voltar</button>
      </div>
      <div class="right">
        <button class="btn btnPrimary" type="button" onclick="gerar15P()">Gerar an√°lise 15P</button>
      </div>
    </div>

    <div class="card" id="p15Area">
      <div class="footerNote">Clique em ‚ÄúGerar an√°lise 15P‚Äù. Essa tela exige o EXTRA ativado (via claims).</div>
    </div>
  </div>
<!-- =========================
   TELA: JOGOS SALVOS
========================= -->
<div class="view" id="viewSavedGames" onshow="renderJogosSalvosAoAbrir()">
  <div class="topNav">
    <div class="left">
      <button class="btn btnGhost" type="button" onclick="goView('viewHome')">‚¨Ö Voltar</button>
    </div>
  </div>

  <div class="card">
    <label>Conferir √∫ltimos concursos</label>
    <select id="savedCheckQtd">
  <option value="3">√öltimos 3</option>
  <option value="6">√öltimos 6</option>
  <option value="12" selected>√öltimos 12</option>
  <option value="20">√öltimos 20</option>
  <option value="30">√öltimos 30</option>
  <option value="50">√öltimos 50</option>
  <option value="75">√öltimos 75</option>
  <option value="100">√öltimos 100</option>
  </select>

<div id="savedPacksList" style="margin-top:14px"></div>

<button class="btn btnPrimary" style="margin-top:10px" onclick="checkSavedGames()">
  Conferir jogos
</button>

<div id="savedGamesResult" style="margin-top:14px"></div>
  </div>
</div>

  <div class="footerNote">Aviso: an√°lise estat√≠stica n√£o garante premia√ß√£o. Jogo respons√°vel ‚úÖ</div>
</div>

<!-- MODAL LISTA CONCURSOS -->
<div id="modalBack" class="modalBack">
  <div class="modal">
    <div class="modalHeader">
      <b>üìå Concursos analisados (datas + dezenas)</b>
      <button class="closeBtn" onclick="fecharModal()">Fechar</button>
    </div>
    <div class="modalBody">
      <div id="listaConcursos"></div>
    </div>
  </div>
</div>

<!-- MODAL GRAFICO BLOCOS -->
<div id="modalBlocosBack" class="modalBack">
  <div class="modal" style="max-width:560px">
    <div class="modalHeader">
      <b>üìä Gr√°fico de Blocos A‚ÄìE</b>
      <button class="closeBtn" onclick="fecharGraficoBlocos()">Fechar</button>
    </div>
    <div class="modalBody">
      <div id="graficoBlocosArea"></div>
      <div class="mini" style="margin-top:10px">
        Blocos: A(01‚Äì05), B(06‚Äì10), C(11‚Äì15), D(16‚Äì20), E(21‚Äì25).
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   UI Helpers
========================= */
document.getElementById("appName1").textContent = APP_NAME;
document.getElementById("appName2").textContent = APP_NAME;

function bindCardKey(el){
  el.addEventListener("keydown", (e)=>{
    if(e.key === "Enter" || e.key === " "){
      e.preventDefault();
      el.click();
    }
  });
}

function showOk(t){
  const a=document.getElementById("msgOk");
  a.style.display="block";
  a.textContent=t;
  document.getElementById("msgErr").style.display="none";
}
function showErr(t){
  const a=document.getElementById("msgErr");
  a.style.display="block";
  a.textContent=t;
  document.getElementById("msgOk").style.display="none";
}

function setStatus(on, text){
  const st=document.getElementById("status");
  document.getElementById("statusText").textContent = text || "";
  st.style.display = on ? "block" : "none";
  toggleProgressCol(); // ‚úÖ garante alinhamento no mobile
}
function toggleProgressCol(){
  const st = document.getElementById("status");
  if(!st) return;

  const col = st.closest(".col");
  if(!col) return;

  const isMobile = window.innerWidth <= 520;
  const statusVisible = (getComputedStyle(st).display !== "none");

  if(isMobile && !statusVisible){
    col.style.display = "none";
  }else{
    col.style.display = "block";
  }
}

window.addEventListener("resize", toggleProgressCol);
document.addEventListener("DOMContentLoaded", toggleProgressCol);

function setProgress(p){
  document.getElementById("barFill").style.width = Math.max(0, Math.min(100, p)) + "%";
}

function abrirModal(){ document.getElementById("modalBack").style.display="flex"; }
function fecharModal(){ document.getElementById("modalBack").style.display="none"; }
function fecharGraficoBlocos(){ document.getElementById("modalBlocosBack").style.display="none"; }

function goView(id){
  document.querySelectorAll('.view').forEach(v => v.style.display='none');
  document.getElementById(id).style.display='block';

  // ‚úÖ Ao abrir "JOGOS SALVOS"
  if(id === 'viewSavedGames'){
    renderJogosSalvosAoAbrir();
    return;
  }

  // ‚úÖ Auto-a√ß√£o ao abrir as telas (sem "remendos")
  // - Principal: se ainda n√£o existe, gera automaticamente (respeita Free/Premium pela pr√≥pria acaoPrincipal)
  // - Invertida/T√©cnica: se existe Principal, gera automaticamente ao entrar na tela (Premium)
  if(id === 'viewPrincipal'){
    const el = document.getElementById("principalArea");
    const temMsg = el && /Gere um Jogo Principal/i.test(el.textContent||"");

    if(!lastPrincipalGame){
      if(!window.__autoGenLock){
        window.__autoGenLock = true;
        Promise.resolve().then(()=>acaoPrincipal()).finally(()=>{ window.__autoGenLock = false; });
      }
      return;
    }

    // Se j√° existe jogo mas a tela ainda est√° com a mensagem, renderiza algo m√≠nimo imediatamente
    if(temMsg){
      const balls = lastPrincipalGame.map(n=>`<div class="ball">${format2(n)}</div>`).join("");
      el.innerHTML = `
        <div class="box">
          <b>üéØ Jogo Principal</b>
          <div class="numbers" style="justify-content:flex-start">${balls}</div>
        </div>
      `;
    }
    return;
  }

  if(id === 'viewInvertida'){
    if(access?.premium && lastPrincipalGame){
      gerarInvertida(true);
    }
    return;
  }

  if(id === 'viewTecnica'){
    if(access?.premium && lastPrincipalGame){
      gerarTecnicaPremiada(true);
    }
    return;
  }
}
</script>

<script>
/* =========================
   AUTH + CLAIMS (Premium/15P)
========================= */
let access = {
  email: "",
  uid: "",
  premium: false,
  addon15: false,
  isAdmin: false
};

async function refreshClaims(force=false){
  const u = auth.currentUser;
  if(!u) return access;

  const token = await u.getIdTokenResult(!!force);
  const email = (u.email || "").toLowerCase();
  const isAdmin = email === String(ADMIN_EMAIL).toLowerCase();

  const premium = !!token.claims.premium || isAdmin;
  const addon15 = !!token.claims.addon15 || isAdmin;

  access = { email, uid: u.uid, premium, addon15, isAdmin };
  updateChip();
  aplicarAcessos();
  return access;
}

function updateChip(){
  const plan = access.isAdmin ? "üõ°Ô∏è Admin" : (access.premium ? "üëë Premium" : "üë§ Free");
  const extra = (access.addon15 || access.isAdmin) ? " ‚Ä¢ ‚úÖ 15P" : "";
  const chipTextEl = document.getElementById("chipText");
  if(chipTextEl) chipTextEl.textContent = `${plan} ‚Ä¢ ${access.email || "‚Äî"}${extra}`;
}

/* ‚úÖ Free 1x (localStorage por UID) */
function isFreeUsed(){
  if(!access.uid) return false;
  return localStorage.getItem(freeKey(access.uid)) === "1";
}
function markFreeUsed(){
  if(!access.uid) return;
  localStorage.setItem(freeKey(access.uid), "1");
}

function setCardEnabled(el, enabled, onClick, msg){
  if(!el) return;
  el.classList.toggle("disabled", !enabled);
  el.onclick = enabled ? onClick : ()=>alert(msg);
}

function aplicarAcessos(){
  const can15p = ((access.premium && access.addon15) || access.isAdmin);

  const premiumGate = document.getElementById("premiumGate");
  if(premiumGate) premiumGate.style.display = access.premium ? "none" : "block";

  const addon15Card = document.getElementById("addon15Card");
  if(addon15Card) addon15Card.style.display = (!access.isAdmin && !can15p) ? "block" : "none";

  const btnAnalise  = document.getElementById("btnHomeAnalise");
  const btnPrincipal= document.getElementById("btnHomePrincipal");
  const btnInvertida= document.getElementById("btnHomeInvertida");
  const btnTecnica  = document.getElementById("btnHomeTecnica");
  const btn15       = document.getElementById("btnHome15p");

  setCardEnabled(btnAnalise, access.premium, acaoAnalise, "üîí Gerar an√°lise exige Premium.");

  setCardEnabled(btnInvertida, access.premium, ()=>{
    goView("viewInvertida"); gerarInvertida();
  }, "üîí Invertida exige Premium.");

  setCardEnabled(btnTecnica, access.premium, ()=>{
    goView("viewTecnica"); gerarTecnicaPremiada();
  }, "üîí T√©cnica premiada exige Premium.");

  if(!access.premium && isFreeUsed()){
    btnPrincipal?.classList.add("disabled");
    if(btnPrincipal) btnPrincipal.onclick = ()=>alert("üîí Voc√™ j√° usou a gera√ß√£o gr√°tis. Para liberar, ative o Premium.");
  }else{
    btnPrincipal?.classList.remove("disabled");
    if(btnPrincipal) btnPrincipal.onclick = ()=>acaoPrincipal();
  }

  if(!can15p){
    btn15?.classList.add("disabled");
    if(btn15) btn15.onclick = ()=>alert("üîí O recurso '15 pontos garantido' √© um EXTRA comprado separadamente (libera via claims).");
  }else{
    btn15?.classList.remove("disabled");
    if(btn15) btn15.onclick = ()=>{ goView("view15p"); };
  }
}

function abrirApp(){
  document.getElementById("loginWrap").style.display="none";
  document.getElementById("app").style.display="block";
  goView("viewHome");
}

function fecharApp(){
  document.getElementById("loginWrap").style.display="flex";
  document.getElementById("app").style.display="none";
}

/* ===== LOGIN / CRIAR CONTA ===== */
async function entrar(){
  const e=(document.getElementById("email").value||"").trim().toLowerCase();
  const s=(document.getElementById("senha").value||"");
  if(!e || !s){ showErr("Digite email e senha."); return; }

  const btn = document.getElementById("btnEntrar");
  btn.disabled = true;

  try{
    await auth.signInWithEmailAndPassword(e,s);
    showOk("Bem-vindo! Carregando seu acesso‚Ä¶");
  }catch(err){
    try{
      await auth.createUserWithEmailAndPassword(e,s);
      showOk("Conta criada ‚úÖ Carregando seu acesso‚Ä¶");
    }catch(e2){
      showErr(e2?.message || "Falha no login.");
    }
  }finally{
    btn.disabled = false;
  }
}

async function forgotPassword(){
  const e=(document.getElementById("email").value||"").trim().toLowerCase();
  if(!e) return showErr("Digite seu email para recuperar a senha.");
  try{
    await auth.sendPasswordResetEmail(e);
    showOk("‚úÖ Email de recupera√ß√£o enviado. Verifique sua caixa de entrada.");
  }catch(err){
    showErr(err?.message || "N√£o foi poss√≠vel enviar o email de recupera√ß√£o.");
  }
}

function sair(){ auth.signOut(); }

function comprarPremium(){ window.open(BUY_LINK, "_blank"); }
function comprar15p(){ window.open(BUY_LINK_15P, "_blank"); }

/* ===== ATIVA√á√ÉO POR C√ìDIGO (Cloud Function redeemCode) ===== */
async function ativarComCodigo(){
  try{
    if(!auth.currentUser){
      alert("Voc√™ precisa estar logado.");
      return;
    }
    const code = prompt("Cole aqui seu C√ìDIGO de ativa√ß√£o (ex: PRIME-0001):");
    if(!code) return;

    showOk("Ativando c√≥digo‚Ä¶");
    const redeemCode = functions.httpsCallable("redeemCode");
    await redeemCode({ code: code.trim() });

    await refreshClaims(true);

    if(access.premium || access.addon15 || access.isAdmin){
      showOk("‚úÖ C√≥digo ativado! Seus acessos foram atualizados.");
    }else{
      showOk("‚úÖ C√≥digo enviado! Se n√£o liberar na hora, saia e entre novamente.");
    }
  }catch(err){
    console.log(err);
    showErr("‚ùå Erro ao ativar: " + (err?.message || err));
  }
}

async function jaComprei(){ await ativarComCodigo(); }
async function jaComprei15p(){ await ativarComCodigo(); }

/* ===== AUTOSTATE ===== */
auth.onAuthStateChanged(async (user)=>{
  if(!user){
    access = { email:"", uid:"", premium:false, addon15:false, isAdmin:false };
    fecharApp();
    return;
  }
  abrirApp();
  await refreshClaims(true);
});
</script>

<script>
/* =========================
   MOTOR BASE
========================= */
function format2(n){ return String(n).padStart(2,"0"); }

/* =========================
   ‚úÖ Trocas por COLUNAS (cart√£o 5x5) + cards ilustrativos (SVG)
========================= */
function inverterJogoPorColPerm(jogo, colMap){
  // colMap: array [c1->?, c2->?, c3->?, c4->?, c5->?] (1..5)
  const out = [];
  const set = new Set();
  for(const n of (jogo||[])){
    const num = Number(n);
    if(!(num>=1 && num<=25)) continue;
    const row = Math.floor((num-1)/5); // 0..4
    const col = ((num-1)%5) + 1;       // 1..5
    const newCol = colMap[col-1];      // 1..5
    const newNum = row*5 + newCol;     // 1..25
    if(!set.has(newNum)){ set.add(newNum); out.push(newNum); }
  }
  // mant√©m ordenado para exibi√ß√£o padr√£o
  out.sort((a,b)=>a-b);
  return out;
}

function buildCardSVG(selectedNums, title){
  const sel = new Set((selectedNums||[]).map(Number));
  const W=520, H=620;
  const pad=26;
  const cell=88, gap=12;
  const gridW = 5*cell + 4*gap;
  const startX = (W - gridW)/2;
  const startY = 92;

  const bg = `
    <defs>
      <radialGradient id="g1" cx="30%" cy="20%" r="85%">
        <stop offset="0%" stop-color="rgba(250,204,21,0.14)"/>
        <stop offset="70%" stop-color="rgba(0,0,0,0)"/>
      </radialGradient>
      <linearGradient id="g2" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#000000"/>
        <stop offset="100%" stop-color="#050505"/>
      </linearGradient>
      <filter id="shadow" x="-30%" y="-30%" width="160%" height="160%">
        <feDropShadow dx="0" dy="10" stdDeviation="12" flood-color="rgba(0,0,0,0.55)"/>
      </filter>
    </defs>
    <rect x="0" y="0" width="${W}" height="${H}" rx="26" fill="url(#g2)"/>
    <rect x="0" y="0" width="${W}" height="${H}" rx="26" fill="url(#g1)"/>
    <rect x="${pad}" y="${pad}" width="${W-2*pad}" height="${H-2*pad}" rx="22"
          fill="rgba(0,0,0,0.55)" stroke="rgba(255,255,255,0.14)"/>
  `;

  let cells="";
  for(let r=0;r<5;r++){
    for(let c=0;c<5;c++){
      const n = r*5 + (c+1);
      const x = startX + c*(cell+gap);
      const y = startY + r*(cell+gap);
      const on = sel.has(n);
      const stroke = on ? "rgba(250,204,21,0.70)" : "rgba(255,255,255,0.16)";
      const fill = "rgba(0,0,0,0.70)";
      const numColor = on ? "#facc15" : "#ffffff";
      cells += `
        <rect x="${x}" y="${y}" width="${cell}" height="${cell}" rx="20"
              fill="${fill}" stroke="${stroke}" stroke-width="3" filter="url(#shadow)"/>
        <text x="${x+cell/2}" y="${y+cell/2+10}" text-anchor="middle"
              font-family="Georgia, 'Times New Roman', serif"
              font-size="34" font-weight="700" fill="${numColor}">
          ${String(n).padStart(2,'0')}
        </text>
      `;
    }
  }

  const t = (title||"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
  const titleBlock = `
    <text x="${W/2}" y="62" text-anchor="middle"
          font-family="Georgia, 'Times New Roman', serif"
          font-size="34" font-weight="700" fill="#ffffff">${t}</text>
  `;

  return `<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${H}" viewBox="0 0 ${W} ${H}">
    ${bg}
    ${titleBlock}
    ${cells}
  </svg>`;
}

function svgToDataUri(svg){
  return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
}


function toNum(d){ return Number(String(d).replace(/^0+/,"")) || Number(d); }
function sortNum(arr){ return arr.slice().sort((a,b)=>a-b); }

function calcularFrequencias(concursos){
  const freq={}; for(let i=1;i<=25;i++) freq[i]=0;
  concursos.forEach(c=>{
    (c.dezenas||[]).forEach(d=>{
      const n=toNum(d);
      if(n>=1 && n<=25) freq[n]+=1;
    });
  });
  return freq;
}
function ordenarPorFreq(freq){
  return Object.entries(freq).map(([k,v])=>({dez:Number(k), f:v})).sort((a,b)=>b.f-a.f);
}
function contarParesImpares(jogo){
  const pares = jogo.filter(n=>n%2===0).length;
  return {pares, impares: jogo.length - pares};
}
function somaDezenas(jogo){ return jogo.reduce((a,b)=>a+b,0); }
function contarSequencias(jogo){
  let maxLen=1, curLen=0, prev=null;
  const sorted = sortNum(jogo);
  for(const n of sorted){
    if(prev!==null && n===prev+1){ curLen++; }
    else { curLen=1; }
    if(curLen>maxLen) maxLen=curLen;
    prev=n;
  }
  return { temSequencia: maxLen>=2, maxLen };
}
function distribuicaoBlocos(jogo){
  const b={A:0,B:0,C:0,D:0,E:0};
  jogo.forEach(n=>{
    if(n>=1 && n<=5) b.A++;
    else if(n>=6 && n<=10) b.B++;
    else if(n>=11 && n<=15) b.C++;
    else if(n>=16 && n<=20) b.D++;
    else if(n>=21 && n<=25) b.E++;
  });
  return b;
}
function repetidasDoUltimo(jogo, ultimoDezenas){
  const setUlt = new Set((ultimoDezenas||[]).map(toNum));
  return sortNum(jogo.filter(n=>setUlt.has(n)));
}

/* üî•/üå°Ô∏è/üßä Classifica√ß√£o por ranking (janela) */
function buildHotWarmColdFromFreq(freq){
  const ord = ordenarPorFreq(freq);
  const hot = ord.slice(0,8).map(x=>x.dez).sort((a,b)=>a-b);
  const warm = ord.slice(8,17).map(x=>x.dez).sort((a,b)=>a-b);
  const cold = ord.slice(17).map(x=>x.dez).sort((a,b)=>a-b);
  return { hot, warm, cold, ord };
}
function classificarDezenas(freq, jogo){
  const ord = ordenarPorFreq(freq);
  const rank={}; ord.forEach((x,i)=>rank[x.dez]=i+1);
  const hot=[], warm=[], cold=[];
  jogo.forEach(n=>{
    const r=rank[n]||999;
    if(r<=8) hot.push(n);
    else if(r<=17) warm.push(n);
    else cold.push(n);
  });
  return {hot:sortNum(hot), warm:sortNum(warm), cold:sortNum(cold), rank};
}
/* =========================
   ‚úÖ HELPERS NOVA L√ìGICA (SEM ALEAT√ìRIO)
========================= */

/* Conta quantas vezes um grupo aparece inteiro em um concurso */
function countGroupTogetherInWindow(group, concursos){
  const gset = new Set(group.map(Number));
  let count = 0;
  for(const c of (concursos || [])){
    const setC = new Set((c.dezenas||[]).map(toNum));
    let ok = true;
    for(const n of gset){
      if(!setC.has(n)){ ok=false; break; }
    }
    if(ok) count++;
  }
  return count;
}

/* Gera todas combina√ß√µes k de um array ordenado */
function combosK(arr, k){
  const res = [];
  function rec(start, path){
    if(path.length === k){ res.push(path.slice()); return; }
    for(let i=start;i<arr.length;i++){
      path.push(arr[i]);
      rec(i+1, path);
      path.pop();
    }
  }
  rec(0, []);
  return res;
}

/* Escolhe o melhor subconjunto (k) DENTRO do √∫ltimo concurso:
   "os que mais aparecem juntos na janela"
   Crit√©rios determin√≠sticos:
   1) maior "juntos" (countGroupTogether)
   2) empate -> maior soma de frequ√™ncia (freq)
   3) empate -> menor soma de gap (menos extremo)
   4) empate -> ordem lexicogr√°fica
*/
function bestSubsetFromLastDraw(lastNums, k, concursos, freq, modern){
  const last = lastNums.slice().map(toNum).filter(n=>n>=1 && n<=25).sort((a,b)=>a-b);
  const all = combosK(last, k);

  let best = null;

  for(const g of all){
    const together = countGroupTogetherInWindow(g, concursos);
    const sumFreq = g.reduce((a,n)=>a+(freq?.[n]||0),0);
    const sumGap  = g.reduce((a,n)=>a+Number(modern?.gap?.[n]||0),0);
    const key = g.map(format2).join("-");

    const cand = { g, together, sumFreq, sumGap, key };

    if(!best) best = cand;
    else{
      if(cand.together > best.together) best = cand;
      else if(cand.together === best.together && cand.sumFreq > best.sumFreq) best = cand;
      else if(cand.together === best.together && cand.sumFreq === best.sumFreq && cand.sumGap < best.sumGap) best = cand;
      else if(cand.together === best.together && cand.sumFreq === best.sumFreq && cand.sumGap === best.sumGap && cand.key < best.key) best = cand;
    }
  }

  return best?.g || last.slice(0,k);
}

/* ‚úÖ NOVA SELE√á√ÉO PREMIUM (grupo "que mais sai junto" na janela)
   - pool: lista de dezenas candidatas (ex: as 15 do √∫ltimo concurso, ou as 10 que N√ÉO sa√≠ram)
   - k: tamanho do grupo
   - avoidSet: (opcional) n√∫meros para evitar repetir entre os 4 jogos (desempate)
   Crit√©rios determin√≠sticos (ordem):
   1) maior "juntos" (quantas vezes o grupo aparece inteiro na janela)
   2) menor overlap com avoidSet (para diversificar os 4 jogos)
   3) maior soma de frequ√™ncia (freq)
   4) menor soma de gap (menos extremo)
   5) ordem lexicogr√°fica
*/
function bestSubsetFromPool(pool, k, concursos, freq, modern, avoidSet){
  const base = (pool||[]).map(toNum).filter(n=>n>=1&&n<=25).sort((a,b)=>a-b);
  const all = combosK(base, k);

  let best = null;

  const avoid = avoidSet instanceof Set ? avoidSet : new Set((avoidSet||[]).map(toNum));

  for(const g of all){
    const together = countGroupTogetherInWindow(g, concursos);
    const overlap  = g.reduce((s,n)=>s + (avoid.has(n)?1:0), 0);
    const sumFreq  = g.reduce((a,n)=>a + (freq?.[n]||0), 0);
    const sumGap   = g.reduce((a,n)=>a + Number(modern?.gap?.[n]||0), 0);
    const key      = g.map(format2).join("-");

    const cand = { g, together, overlap, sumFreq, sumGap, key };

    if(!best) best = cand;
    else{
      if(cand.together > best.together) best = cand;
      else if(cand.together === best.together && cand.overlap < best.overlap) best = cand;
      else if(cand.together === best.together && cand.overlap === best.overlap && cand.sumFreq > best.sumFreq) best = cand;
      else if(cand.together === best.together && cand.overlap === best.overlap && cand.sumFreq === best.sumFreq && cand.sumGap < best.sumGap) best = cand;
      else if(cand.together === best.together && cand.overlap === best.overlap && cand.sumFreq === best.sumFreq && cand.sumGap === best.sumGap && cand.key < best.key) best = cand;
    }
  }

  return best?.g || base.slice(0,k);
}

/* Divide um jogo em (veio no √∫ltimo) e (n√£o veio no √∫ltimo) */
function splitInOutByLatest(game, latestDezenas){
  const latestSet = new Set((latestDezenas||[]).map(toNum));
  const inLast = [];
  const outLast = [];
  (game||[]).map(toNum).forEach(n=>{
    if(latestSet.has(n)) inLast.push(n);
    else outLast.push(n);
  });
  inLast.sort((a,b)=>a-b);
  outLast.sort((a,b)=>a-b);
  return { inLast, outLast, latestSet };
}


/* Top10 frequentes (ordenado desc) */
function getTop10FreqList(freq){
  return ordenarPorFreq(freq).slice(0,10).map(x=>x.dez);
}

/* Top10 atrasadas (ordenado por maior gap) */
function getTop10AtrasadasList(modern){
  const arr = [];
  for(let d=1; d<=25; d++){
    arr.push({ dez:d, gap:Number(modern?.gap?.[d] ?? 0) });
  }
  arr.sort((a,b)=>b.gap-a.gap);
  return arr.slice(0,10).map(x=>x.dez);
}

/* Dupla mais forte da janela (coocorr√™ncia real)
   - usa calcTopPairsCooc que voc√™ j√° tem na An√°lise Prime
*/
function getStrongPair(concursos){
  const pairs = calcTopPairsCooc(concursos, 25); // pega mais para ter fallback
  // primeiro par com count>0
  for(const p of pairs){
    if(p.count > 0) return [p.a, p.b];
  }
  // fallback determin√≠stico (nunca aleat√≥rio)
  return [1,2];
}

/* Padr√£o dominante de pares/√≠mpares na janela */
function getDominantEvenOdd(concursos){
  const dist = calcEvenOddDistribution(concursos);
  if(dist && dist.length){
    return { pares: dist[0].pares, impares: dist[0].impares };
  }
  // fallback determin√≠stico (Lotof√°cil tende ao equil√≠brio)
  return { pares: 7, impares: 8 };
}

/* Seleciona X itens de uma lista, sem repetir e com prefer√™ncia por paridade
   - sem aleat√≥rio
*/
function pickFromListDeterministic(list, needed, set, targetPares, lastSet){
  const out = [];
  const last = lastSet || new Set();

  while(out.length < needed){
    const cur = [...set];
    const curPares = cur.filter(n=>n%2===0).length;
    const needMoreEven = (curPares < targetPares);

    let picked = null;

    // 1) tenta pegar n√∫mero com paridade ‚Äúnecess√°ria‚Äù + n√£o repetida do √∫ltimo
    for(const n of list){
      if(set.has(n)) continue;
      if(last.has(n)) continue;

      if(needMoreEven && (n%2===0)) { picked = n; break; }
      if(!needMoreEven && (n%2===1)) { picked = n; break; }
    }

    // 2) se n√£o achou por paridade, pega o primeiro dispon√≠vel (n√£o repetida do √∫ltimo)
    if(picked === null){
      for(const n of list){
        if(set.has(n)) continue;
        if(last.has(n)) continue;
        picked = n; break;
      }
    }

    // 3) se n√£o tem mais, encerra (n√£o deveria acontecer)
    if(picked === null) break;

    set.add(picked);
    out.push(picked);
  }

  return out;
}


/* ===== M√âTRICAS MODERNAS (tend√™ncia/rec√™ncia/atraso) ===== */
function calcModernMetrics(concursos){
  // concursos esperado em ordem crescente (in√≠cio -> √∫ltimo)
  const n = concursos.length;
  const freq = Array(26).fill(0);
  const decay = Array(26).fill(0);
  const recent10 = Array(26).fill(0);
  const lastSeen = Array(26).fill(-1);

  const DECAY = 0.92; // peso para rec√™ncia (mais novo = mais peso)
  for(let i=0;i<n;i++){
    const nums=(concursos[i].dezenas||[]).map(toNum).filter(x=>x>=1 && x<=25);
    const w = Math.pow(DECAY, (n-1-i)); // √∫ltimo concurso = w=1
    nums.forEach(x=>{
      freq[x] += 1;
      decay[x] += w;
      lastSeen[x] = i;
      if(i >= n-10) recent10[x] += 1;
    });
  }

  const gap = Array(26).fill(999);
  for(let x=1;x<=25;x++){
    gap[x] = (lastSeen[x]===-1) ? n : (n-1-lastSeen[x]);
  }

  // tend√™ncia simples: recente10 comparado com base
  const trend = Array(26).fill(0);
  for(let x=1;x<=25;x++){
    const baseRate = freq[x] / Math.max(1,n);
    const recRate = recent10[x] / Math.max(1, Math.min(10,n));
    trend[x] = (recRate - baseRate);
  }

  return { n, freq, decay, recent10, gap, trend };
}

</script>

<script>
/* =========================
   ‚úÖ NOVO MOTOR JOGO PRINCIPAL (100% PRIME / SEM ALEAT√ìRIO)
   Regra:
   - Base k=8/9/10 do √∫ltimo concurso (k vem da sequ√™ncia 20/50/30)
   - Base escolhida como "as que mais aparecem juntas na janela"
   - Completa com % exatas:
     k=8  -> +3 Top10 freq (2 mais + 1 menos) +2 (dupla forte) +2 atrasadas (mais + menos)
     k=9  -> +2 Top10 freq (1 mais + 1 menos) +2 (dupla forte) +2 atrasadas (mais + menos)
     k=10 -> +2 Top10 freq (1 mais + 1 menos) +2 (dupla forte) +1 atrasada (mais atrasada)
   - Paridade: segue o padr√£o dominante da janela (ex: 7 pares / 8 √≠mpares)
========================= */

function gerarJogoPrincipalPrime(freq, modern, concursos, latestDezenas){
  /* =========================
     ‚úÖ MOTOR PREDITIVO FIXO (JOGO PRINCIPAL)
     Objetivo: prever o pr√≥ximo concurso aplicando um M√âTODO FIXO aprendido no treino,
     SEM buscar ‚Äújogo salvo bom‚Äù nem pontuar passado.

     Como funciona:
     1) Usa a janela N (concursos selecionados) para CLASSIFICAR dezenas por comportamento (letras A‚ÄìH),
        igual ao padr√£o do 15P.
     2) Aplica um TEMPLATE FIXO do PRINCIPAL (quotas por letras + alvo de repetidas + paridade dominante).
     3) Retorna { jogo, motivos } para explicar ao usu√°rio.
  ========================= */

  const conc = (concursos||[]).slice().sort((a,b)=> (a.concurso||0) - (b.concurso||0));
  const N = Math.max(3, conc.length || 3);
  const window = conc.slice(Math.max(0, conc.length - N));
  const ultimo = window[window.length-1] || null;

  const latest = (latestDezenas||[]).map(toNum).filter(n=>n>=1&&n<=25).sort((a,b)=>a-b);
  const lastSet = new Set(latest);

  // bits de presen√ßa (mais antigo -> mais recente)
  const pres = {};
  for(let n=1;n<=25;n++) pres[n] = Array(window.length).fill(0);
  for(let i=0;i<window.length;i++){
    const set = new Set((window[i]?.dezenas||[]).map(toNum));
    for(let n=1;n<=25;n++){
      if(set.has(n)) pres[n][i]=1;
    }
  }

  function lastSeenIdx(bits){
    for(let i=bits.length-1;i>=0;i--) if(bits[i]===1) return (bits.length-1-i); // 0=saiu no √∫ltimo
    return 999;
  }
  function countOn(bits){ return bits.reduce((a,b)=>a+b,0); }

  // Letras A‚ÄìH (fixas para qualquer N)
  function letterOf(n){
    const bits = pres[n];
    const c = countOn(bits);
    if(c===0) return "H";
    const recent = (bits[bits.length-1]===1);

    const high = Math.ceil(bits.length*0.75);
    const med  = Math.ceil(bits.length*0.50);

    if(c>=high) return recent ? "A" : "B";
    if(c>=med)  return recent ? "C" : "D";

    const ls = lastSeenIdx(bits);
    if(recent) return "E";
    if(ls<=2)  return "F";
    return "G";
  }
  function bucket(L){
    if(L==="A"||L==="B") return "hot";
    if(L==="C"||L==="D") return "med";
    if(L==="E"||L==="F"||L==="G") return "low";
    return "zero";
  }

  // ranking estrutural (desempate determin√≠stico; N√ÉO √© ‚Äúpontua√ß√£o do passado‚Äù)
  function rankScore(n){
    const bits = pres[n];
    const c = countOn(bits);
    const ls = lastSeenIdx(bits);
    // presen√ßa pesa mais, rec√™ncia desempata, e leve prefer√™ncia ao que saiu no √∫ltimo (para respeitar repeti√ß√£o alvo)
    return (c*100) + (Math.max(0, 25-ls)*3) + (lastSet.has(n)?2:0);
  }

  // Dominante pares/√≠mpares na janela
  const domEvenOdd = getDominantEvenOdd(window);
  // Alvo de repetidas do √∫ltimo (padr√£o do treino): 9 (aceita 8..10)
  const repTarget = 9;
  const repMin = 8, repMax = 10;

  // ‚úÖ TEMPLATE FIXO do PRINCIPAL (quotas por ‚Äúfam√≠lias‚Äù)
  // (padr√£o aderente ao per√≠odo treinado: muita repeti√ß√£o + n√∫cleo quente + complemento)
  const quotas = { hot: 9, med: 5, low: 1, zero: 0 }; // soma 15

  // monta pools por bucket
  const pools = { hot:[], med:[], low:[], zero:[] };
  for(let n=1;n<=25;n++){
    const L = letterOf(n);
    pools[bucket(L)].push(n);
  }
  // ordena determin√≠stico (melhor rankScore primeiro)
  for(const k of Object.keys(pools)){
    pools[k].sort((a,b)=> rankScore(b)-rankScore(a) || a-b);
  }

  // Sele√ß√£o com controle de repetidas do √∫ltimo
  const chosen = new Set();

  function canPick(n){
    return n>=1 && n<=25 && !chosen.has(n);
  }
  function curRepCount(){
    let c=0; for(const n of chosen) if(lastSet.has(n)) c++;
    return c;
  }
  function curCountWhere(pred){
    let c=0; for(const n of chosen) if(pred(n)) c++;
    return c;
  }

  // escolhe k itens de um bucket com prefer√™ncia (inLast ou outLast) para bater repTarget
  function pickFromBucket(bucketName, k, preferInLast){
    const pool = pools[bucketName] || [];
    for(const n of pool){
      if(chosen.size>=15) break;
      if(k<=0) break;
      if(!canPick(n)) continue;

      const inLast = lastSet.has(n);
      if(preferInLast === true && !inLast) continue;
      if(preferInLast === false && inLast) continue;

      chosen.add(n);
      k--;
    }
    return k;
  }

  // estrat√©gia:
  // 1) garantir uma base de repetidas (n√∫cleo) usando HOT+MED que sa√≠ram no √∫ltimo
  let needRep = repTarget;
  needRep = pickFromBucket("hot", Math.min(quotas.hot, needRep), true) + Math.max(0, needRep - Math.min(quotas.hot, needRep)); // placeholder
  // acima ficou ‚Äúestranho‚Äù por causa do retorno; refazemos abaixo de forma clara:
  chosen.clear();

  // (A) pega repetidas primeiro (hot/med preferindo inLast)
  let hotLeft = quotas.hot;
  let medLeft = quotas.med;
  let lowLeft = quotas.low;
  let zeroLeft = quotas.zero;

  // repetidas: distribui entre hot/med/low conforme disponibilidade
  let repLeft = repTarget;

  // hot repetidas
  for(const n of pools.hot){
    if(repLeft<=0 || hotLeft<=0) break;
    if(!canPick(n)) continue;
    if(!lastSet.has(n)) continue;
    chosen.add(n); repLeft--; hotLeft--;
  }
  // med repetidas
  for(const n of pools.med){
    if(repLeft<=0 || medLeft<=0) break;
    if(!canPick(n)) continue;
    if(!lastSet.has(n)) continue;
    chosen.add(n); repLeft--; medLeft--;
  }
  // low repetidas (s√≥ se necess√°rio)
  for(const n of pools.low){
    if(repLeft<=0 || lowLeft<=0) break;
    if(!canPick(n)) continue;
    if(!lastSet.has(n)) continue;
    chosen.add(n); repLeft--; lowLeft--;
  }

  // (B) completa com ‚Äúfora do √∫ltimo‚Äù (para fechar 15 e garantir diversidade)
  // hot fora
  for(const n of pools.hot){
    if(chosen.size>=15 || hotLeft<=0) break;
    if(!canPick(n)) continue;
    if(lastSet.has(n)) continue;
    chosen.add(n); hotLeft--;
  }
  // med fora
  for(const n of pools.med){
    if(chosen.size>=15 || medLeft<=0) break;
    if(!canPick(n)) continue;
    if(lastSet.has(n)) continue;
    chosen.add(n); medLeft--;
  }
  // low fora
  for(const n of pools.low){
    if(chosen.size>=15 || lowLeft<=0) break;
    if(!canPick(n)) continue;
    if(lastSet.has(n)) continue;
    chosen.add(n); lowLeft--;
  }
  // zero fora (normalmente 0 no PRINCIPAL)
  for(const n of pools.zero){
    if(chosen.size>=15 || zeroLeft<=0) break;
    if(!canPick(n)) continue;
    if(lastSet.has(n)) continue;
    chosen.add(n); zeroLeft--;
  }

  // (C) se ainda faltou completar 15 (caso raro), completa determin√≠stico pela ordem geral (evitando H)
  if(chosen.size<15){
    const all = [];
    for(let n=1;n<=25;n++) all.push(n);
    all.sort((a,b)=> rankScore(b)-rankScore(a) || a-b);
    for(const n of all){
      if(chosen.size>=15) break;
      if(!canPick(n)) continue;
      // evita H no principal (s√≥ entra se for inevit√°vel)
      if(letterOf(n)==="H") continue;
      chosen.add(n);
    }
  }
  // se MESMO assim faltou (ultra raro), aceita qualquer
  if(chosen.size<15){
    for(let n=1;n<=25 && chosen.size<15;n++){
      if(canPick(n)) chosen.add(n);
    }
  }

  // Ajusta repetidas para ficar no intervalo 8..10
  function adjustReps(){
    let reps = curRepCount();
    const chosenArr = [...chosen].sort((a,b)=>a-b);

    // se tem repetidas demais, troca repetidas por fora do √∫ltimo mantendo letra ‚Äúpr√≥xima‚Äù
    if(reps > repMax){
      // candidatos para remover: repetidas de menor rank
      const remove = chosenArr.filter(n=>lastSet.has(n))
        .sort((a,b)=> rankScore(a)-rankScore(b) || a-b);

      // candidatos para entrar: fora do √∫ltimo com maior rank, evitando H
      const addPool = [];
      for(let n=1;n<=25;n++){
        if(chosen.has(n)) continue;
        if(lastSet.has(n)) continue;
        if(letterOf(n)==="H") continue;
        addPool.push(n);
      }
      addPool.sort((a,b)=> rankScore(b)-rankScore(a) || a-b);

      let ai=0;
      for(const r of remove){
        if(reps<=repMax || ai>=addPool.length) break;
        chosen.delete(r);
        chosen.add(addPool[ai++]);
        reps = curRepCount();
      }
    }

    // se tem repetidas de menos, troca fora do √∫ltimo por repetida forte
    reps = curRepCount();
    if(reps < repMin){
      const remove = chosenArr.filter(n=>!lastSet.has(n))
        .sort((a,b)=> rankScore(a)-rankScore(b) || a-b);

      const addPool = latest.filter(n=>!chosen.has(n))
        .sort((a,b)=> rankScore(b)-rankScore(a) || a-b);

      let ai=0;
      for(const r of remove){
        if(reps>=repMin || ai>=addPool.length) break;
        chosen.delete(r);
        chosen.add(addPool[ai++]);
        reps = curRepCount();
      }
    }
  }
  adjustReps();

  // Ajusta paridade para o dominante (pares alvo)
  function adjustParity(){
    const targetPares = domEvenOdd.pares;
    function countEven(set){ let c=0; for(const n of set) if(n%2===0) c++; return c; }
    let curEven = countEven(chosen);
    const needMoreEven = () => curEven < targetPares;
    const needLessEven = () => curEven > targetPares;

    // pools de troca
    const allCandidates = [];
    for(let n=1;n<=25;n++){
      if(chosen.has(n)) continue;
      allCandidates.push(n);
    }
    allCandidates.sort((a,b)=> rankScore(b)-rankScore(a) || a-b);

    let guard=0;
    while((needMoreEven() || needLessEven()) && guard++ < 60){
      if(needMoreEven()){
        // remove um √≠mpar mais fraco e coloca um par forte fora do conjunto
        const rem = [...chosen].filter(n=>n%2===1).sort((a,b)=> rankScore(a)-rankScore(b) || a-b)[0];
        const add = allCandidates.find(n=>n%2===0);
        if(rem==null || add==null) break;
        chosen.delete(rem);
        chosen.add(add);
      }else if(needLessEven()){
        const rem = [...chosen].filter(n=>n%2===0).sort((a,b)=> rankScore(a)-rankScore(b) || a-b)[0];
        const add = allCandidates.find(n=>n%2===1);
        if(rem==null || add==null) break;
        chosen.delete(rem);
        chosen.add(add);
      }
      curEven = countEven(chosen);
      // mant√©m repetidas dentro da faixa
      adjustReps();
    }
  }
  adjustParity();

  const jogo = [...chosen].map(Number).sort((a,b)=>a-b);

  // ‚úÖ Motivos (por dezena + resumo do m√©todo)
  const motivos = buildMotivosPrincipalPreditivo(jogo, window, latest, { letterOf, bucket, domEvenOdd, quotas, repTarget, repMin, repMax });

  return { jogo, motivos };
}

function buildMotivosPrincipalPreditivo(jogo, window, latest, ctx){
  const lastSet = new Set((latest||[]).map(toNum));
  const N = (window||[]).length || 0;

  function gapOf(n){
    // tenta usar ctx.letterOf (que j√° usa bits), mas para mostrar ‚Äúgap‚Äù simples:
    // procura do fim para o come√ßo
    const w = (window||[]);
    for(let i=w.length-1;i>=0;i--){
      const set = new Set((w[i]?.dezenas||[]).map(toNum));
      if(set.has(n)) return (w.length-1-i);
    }
    return 999;
  }

  const linhas = [];
  const chosenSet = new Set(jogo.map(Number));

  for(const n of jogo){
    const L = ctx?.letterOf ? ctx.letterOf(Number(n)) : "?";
    const b = ctx?.bucket ? ctx.bucket(L) : "?";
    const g = gapOf(Number(n));
    const inLast = lastSet.has(Number(n));

    const bucketTxt = (b==="hot") ? "Quente (A/B)"
                    : (b==="med") ? "M√©dia (C/D)"
                    : (b==="low") ? "Baixa (E/F/G)"
                    : "Adormecida (H)";

    const parts = [];
    parts.push(`üß© Letra <b>${L}</b> ‚Ä¢ ${bucketTxt} na janela`);
    parts.push(inLast ? "üîÅ repetiu do √∫ltimo concurso" : "üÜï veio de fora do √∫ltimo");
    if(g===0) parts.push("‚ö° saiu no √∫ltimo (rec√™ncia m√°xima)");
    else if(g<=2) parts.push(`‚ö° rec√™ncia forte (h√° ${g} concurso[s])`);
    else if(g<999) parts.push(`‚è≥ estava h√° ${g} concursos sem sair`);
    else parts.push("‚è≥ n√£o saiu na janela");

    // Paridade/estrutura (informativo, n√£o muda regra)
    parts.push(`‚öñÔ∏è m√©todo mira ${ctx?.domEvenOdd?.pares ?? 7} pares / ${ctx?.domEvenOdd?.impares ?? 8} √≠mpares`);

    linhas.push({ dezena: Number(n), texto: parts.join(" ‚Ä¢ ") });
  }

  // resumo do m√©todo (vai ser agrupado no UI)
  const reps = jogo.filter(n=>lastSet.has(Number(n))).length;
  linhas.push({
    dezena: jogo[0],
    texto: `üìå PADR√ÉO PREDITIVO FIXO (Principal): quotas Quentes ${ctx?.quotas?.hot ?? 9}, M√©dias ${ctx?.quotas?.med ?? 5}, Baixas ${ctx?.quotas?.low ?? 1}, Adormecidas ${ctx?.quotas?.zero ?? 0} ‚Ä¢ Repetidas alvo ${ctx?.repTarget ?? 9} (aceita ${ctx?.repMin ?? 8}‚Äì${ctx?.repMax ?? 10}) ‚Ä¢ Janela N=${N} ‚Ä¢ Repetidas no jogo: ${reps}`
  });

  return linhas;
}
/* ‚úÖ Motivos por grupo (igual ao padr√£o do print, agrup√°vel) */
function buildMotivosPrime(jogo, picks, domEvenOdd, modern, freq, concursos){
  const baseSet = new Set((picks.base||[]).map(Number));
  const freqSet = new Set((picks.freq||[]).map(Number));
  const pairSet = new Set((picks.pair||[]).map(Number));
  const atrSet  = new Set((picks.atrasadas||[]).map(Number));

  const top10freq = getTop10FreqList(freq);
  const top10atr  = getTop10AtrasadasList(modern);

  function motivoPara(n){
    const parts = [];

    // Origem (categoria)
    if(baseSet.has(n)) parts.push(`üîÅ veio do √∫ltimo concurso (n√∫cleo ${picks.k})`);
    if(freqSet.has(n)){
      const idx = top10freq.indexOf(n);
      if(idx === 0) parts.push("üìä √© a MAIS frequente do Top10");
      else if(idx === top10freq.length-1) parts.push("üìä √© a MENOS frequente do Top10");
      else parts.push("üìä faz parte do Top10 frequentes");
    }
    if(pairSet.has(n)) parts.push("üîó pertence √† DUPLA forte (mais saem juntas na janela)");
    if(atrSet.has(n)){
      const idx = top10atr.indexOf(n);
      if(idx === 0) parts.push("‚è≥ √© a MAIS atrasada do Top10");
      else if(idx === top10atr.length-1) parts.push("‚è≥ √© a MENOS atrasada do Top10");
      else parts.push("‚è≥ faz parte do Top10 atrasadas");
    }

    // Rec√™ncia / atraso (info extra, sem mudar regra)
    const gap = Number(modern?.gap?.[n] ?? 0);
    if(gap <= 2) parts.push("‚ö° apareceu recentemente (rec√™ncia forte)");
    if(gap >= 8) parts.push(`‚è≥ est√° h√° ${gap} concursos sem aparecer`);

    // Paridade dominante (info)
    parts.push(`‚öñÔ∏è segue padr√£o dominante: ${domEvenOdd.pares} pares / ${domEvenOdd.impares} √≠mpares`);

    // Remove duplicatas determin√≠stico
    const uniq = [];
    const seen = new Set();
    for(const p of parts){
      if(!seen.has(p)){ seen.add(p); uniq.push(p); }
    }

    return uniq.join(" ‚Ä¢ ");
  }

  return jogo.map(n=>({ dezena:n, texto: motivoPara(n) }));
}
/* =========================
   ‚úÖ NOVO MOTOR (Jogo Principal por regra do √∫ltimo concurso)
   - Repeti√ß√£o: 6 a 11 dezenas do √∫ltimo
   - Complemento: dentre as 10 que N√ÉO sa√≠ram no √∫ltimo (completa at√© 15)
   - Retorna { jogo, motivos }
========================= */
function gerarJogoComRegrasUltimo(freq, metrics, dezenasUltimo){
  const ultimo = (dezenasUltimo||[]).map(toNum).filter(n=>n>=1 && n<=25);
  const setUlt = new Set(ultimo);

  // 10 dezenas que N√ÉO sa√≠ram no √∫ltimo
  const naoSaiu = [];
  for(let n=1;n<=25;n++){
    if(!setUlt.has(n)) naoSaiu.push(n);
  }

  function scoreJogo(jogo){
    const pi = contarParesImpares(jogo);
    const soma = somaDezenas(jogo);
    const blocos = distribuicaoBlocos(jogo);
    const seq = contarSequencias(jogo);

    let score=0;

    // (1) Pares/√≠mpares: ideal 7/8
    score += (pi.pares===7 || pi.pares===8) ? 25 : (pi.pares===6 || pi.pares===9) ? 12 : 0;

    // (2) Soma: faixa comum
    score += (soma>=170 && soma<=230) ? 20 : (soma>=160 && soma<=240) ? 10 : 0;

    // (3) Blocos: evitar concentra√ß√£o
    const maxBlock = Math.max(blocos.A,blocos.B,blocos.C,blocos.D,blocos.E);
    score += (maxBlock<=5) ? 20 : (maxBlock===6) ? 10 : 0;

    // (4) Sequ√™ncia: evitar sequ√™ncia enorme
    score += (seq.maxLen<=4) ? 15 : (seq.maxLen===5) ? 6 : 0;

    // (5) Frequ√™ncia (janela)
    score += Math.min(20, Math.round(jogo.reduce((a,n)=>a+(freq[n]||0),0)/10));

    // (6) Rec√™ncia (se tiver metrics)
    if(metrics){
      const recScore = jogo.reduce((a,n)=>a+(metrics.decay?.[n]||0),0);
      score += Math.min(12, recScore);
    }

    return score;
  }

  // escolhe uma combina√ß√£o boa dentro das regras:
  // repete r (6..11) do √∫ltimo e completa com (15-r) das 10 que n√£o sa√≠ram
  let best=null;

  function pickRandom(arr, k){
    const a=arr.slice().sort(()=>Math.random()-0.5);
    return a.slice(0,k);
  }

  for(let tries=0; tries<1200; tries++){
    // ‚úÖ repeti√ß√£o com PESO (prefer√™ncia em 7 e 8)
function pickRWeighted(){
  const opts = [
    { r: 4, w: 1 },
    { r: 5, w: 2 },
    { r: 6, w: 3 },
    { r: 7, w: 7 }, // ‚≠ê preferido
    { r: 8, w: 7 }, // ‚≠ê preferido
    { r: 9, w: 3 },
    { r: 10, w: 2 },
    { r: 11, w: 1 }
  ];
  const total = opts.reduce((a,x)=>a+x.w,0);
  let roll = Math.random() * total;
  for(const o of opts){
    roll -= o.w;
    if(roll <= 0) return o.r;
  }
  return 7;
}

    const r = pickRWeighted(); // 4..11 (com prefer√™ncia em 7/8)
    const rep = pickRandom(ultimo, Math.min(r, ultimo.length));
    const restCount = 15 - rep.length;

    const comp = pickRandom(naoSaiu, restCount);

    const set = new Set([...rep, ...comp]);
    while(set.size<15){
      set.add(Math.floor(Math.random()*25)+1);
    }

    const jogo = sortNum([...set]);

    // garante que a quantidade de repetidas do √∫ltimo est√° entre 6 e 11
    const reps = jogo.filter(n=>setUlt.has(n));
    if(reps.length < 4 || reps.length > 11) continue;

    // garante que veio uma quantidade boa do grupo "n√£o saiu"
    const doNaoSaiu = jogo.filter(n=>!setUlt.has(n));
    // voc√™ falou que costuma sair de 4 a 10 dessas 10
    if(doNaoSaiu.length < 4 || doNaoSaiu.length > 10) continue;

    const sc = scoreJogo(jogo);
    if(!best || sc > best.score){
      best = { jogo, score: sc, reps, doNaoSaiu };
    }
  }

  // fallback: se por algum motivo n√£o achou (raro), usa o antigo
  if(!best){
    const fallback = gerarJogoForte(freq, metrics);
    return { jogo: fallback, motivos: buildMotivos(fallback, ultimo, freq, metrics) };
  }

  // monta motivos (pra mostrar ao usu√°rio)
  const motivos = buildMotivos(best.jogo, ultimo, freq, metrics);

  return { jogo: best.jogo, motivos };
}

/* ‚úÖ Motivos ‚Äúpopulares‚Äù por dezena */
function buildMotivos(jogo, dezenasUltimoNums, freq, metrics){
  const setUlt = new Set((dezenasUltimoNums||[]).map(toNum));
  const ord = ordenarPorFreq(freq);
  const rank = {};
  ord.forEach((x,i)=>rank[x.dez]=i+1);

  return jogo.map(n=>{
    const isRep = setUlt.has(n);
    const r = rank[n] || 999;
    
    const gap = metrics?.gap?.[n];
    const trend = metrics?.trend?.[n];

    const motivos = [];

    if(isRep) motivos.push("üîÅ veio do √∫ltimo concurso (tende a repetir bastante)");
    else motivos.push("üÜï n√£o saiu no √∫ltimo (normal entrar 4 a 10 dessas no pr√≥ximo)");

    if(typeof gap === "number"){
      if(gap>=8) motivos.push(`‚è≥ est√° h√° ${gap} concursos sem aparecer (pode ‚Äòpintar‚Äô)`);
      else if(gap<=2) motivos.push("‚ö° apareceu recentemente (rec√™ncia forte)");
    }

    if(typeof trend === "number"){
      if(trend>0.03) motivos.push("üìà est√° ‚Äòsubindo‚Äô agora (√∫ltimos concursos)");
    }

    return { dezena:n, texto: motivos.join(" ‚Ä¢ ") };
  });
}
</script>

<script>
function renderTop10(freq, totalConcursos){
  const ord = ordenarPorFreq(freq).slice(0,10);
  const max = ord[0]?.f || 1;
  const bars = ord.map(x=>{
    const pct = Math.round((x.f/max)*100);
    return `
      <div style="display:flex;align-items:center;gap:10px;margin:10px 0">
        <div style="width:90px;color:var(--text);font-weight:950">Dezena ${format2(x.dez)}</div>
        <div style="flex:1;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.12);border-radius:999px;overflow:hidden;height:16px">
          <div style="height:100%;width:${pct}%;background:linear-gradient(90deg,var(--accent),var(--orange))"></div>
        </div>
        <div style="width:56px;text-align:right;color:var(--text);font-weight:950">${x.f}x</div>
      </div>
    `;
  }).join("");

  return `
    <div class="box" style="margin-top:12px">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
        <b>üìä Top 10 dezenas mais frequentes</b>
        <span class="mini" style="margin:0">Base: <b>${totalConcursos}</b> concursos</span>
      </div>
      <div class="mini">Barras maiores = dezenas que mais apareceram no per√≠odo analisado.</div>
      <div style="margin-top:10px">${bars}</div>
    </div>
  `;
}
function renderTop10Atrasadas(modern, totalConcursos){
  // modern.gap[x] = quantos concursos est√° sem aparecer (0 = saiu no √∫ltimo)
  if(!modern || !modern.gap) return "";

  const arr = [];
  for(let d=1; d<=25; d++){
    arr.push({ dez: d, gap: Number(modern.gap[d] ?? 0) });
  }

  // maior atraso primeiro
  arr.sort((a,b)=>b.gap-a.gap);

  const top = arr.slice(0,10);
  const max = top[0]?.gap || 1;

  // barras (igual ao Top 10 frequentes, mas usando gap)
  const bars = top.map(x=>{
    const pct = Math.round((x.gap / max) * 100);
    return `
      <div style="display:flex;align-items:center;gap:10px;margin:10px 0">
        <div style="width:90px;color:var(--text);font-weight:950">Dezena ${format2(x.dez)}</div>
        <div style="flex:1;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.12);border-radius:999px;overflow:hidden;height:16px">
          <div style="height:100%;width:${pct}%;background:linear-gradient(90deg,var(--accent),var(--orange))"></div>
        </div>
        <div style="width:90px;text-align:right;color:var(--text);font-weight:950">${x.gap} atrasos</div>
      </div>
    `;
  }).join("");

  // lista em texto, embaixo do gr√°fico
  const lista = top.map(x=>{
    return `<div class="mini" style="margin:6px 0"><b>Dezena ${format2(x.dez)}</b> ‚Äî <b>${x.gap}</b> concurso(s) sem sair</div>`;
  }).join("");

  return `
  <div class="box" style="margin-top:12px">
    <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:center">
      <b>‚è≥ TOP 10 DE DEZENAS ATRASADAS</b>
      <span class="mini" style="margin:0">Base: <b>${totalConcursos}</b> concursos</span>
    </div>

    <div class="mini" style="margin-top:6px">
      Barra maior = dezena h√° mais concursos sem aparecer (atraso).
    </div>

    <div style="margin-top:10px">
      ${bars}
    </div>
  </div>
`;
}

function renderListaConcursos(concursos){
  const rows = concursos.map(c=>{
    const dezenas = (c.dezenas||[]).map(d=>format2(toNum(d))).join(" - ");
    const data = c.data ? String(c.data) : "‚Äî";
    return `<tr>
      <td><b>${c.concurso}</b></td>
      <td>${data}</td>
      <td class="mono">${dezenas}</td>
    </tr>`;
  }).join("");
  return `
    <table class="table">
      <thead>
              <tr>
                <th>Linha</th>
                <th>Tipo</th>
                <th>Dezenas</th>
                <th>Letras (A‚ÄìH)</th>
                <th>Perfil</th>
                <th>Estrutura</th>
              </tr>
            </thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}

function abrirGraficoBlocos(blocos){
  const max = Math.max(blocos.A,blocos.B,blocos.C,blocos.D,blocos.E,1);
  function row(label, val){
    const pct = Math.round((val/max)*100);
    return `
      <div style="display:flex;align-items:center;gap:10px;margin:10px 0">
        <div style="width:90px;color:var(--text);font-weight:950">${label}</div>
        <div style="flex:1;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.12);border-radius:999px;overflow:hidden;height:16px">
          <div style="height:100%;width:${pct}%;background:linear-gradient(90deg,var(--accent),var(--orange))"></div>
        </div>
        <div style="width:56px;text-align:right;color:var(--text);font-weight:950">${val}</div>
      </div>`;
  }
  document.getElementById("graficoBlocosArea").innerHTML =
    row("A (01‚Äì05)", blocos.A) +
    row("B (06‚Äì10)", blocos.B) +
    row("C (11‚Äì15)", blocos.C) +
    row("D (16‚Äì20)", blocos.D) +
    row("E (21‚Äì25)", blocos.E);

  document.getElementById("modalBlocosBack").style.display="flex";
}
</script>

<script>
/* =========================
   AN√ÅLISE PRIME (mais completa)
========================= */
function calcEvenOddDistribution(concursos){
  const map = {};
  concursos.forEach(c=>{
    const nums = (c.dezenas||[]).map(toNum).filter(n=>n>=1 && n<=25);
    const pares = nums.filter(n=>n%2===0).length;
    const impares = nums.length - pares;
    const key = `${pares}-${impares}`;
    map[key] = (map[key]||0)+1;
  });
  return Object.entries(map)
    .map(([k,v])=>{
      const [p,i] = k.split("-").map(Number);
      return { pares:p, impares:i, count:v };
    })
    .sort((a,b)=>b.count-a.count);
}

function calcSumDistribution(concursos){
  const map = {};
  concursos.forEach(c=>{
    const nums=(c.dezenas||[]).map(toNum).filter(n=>n>=1 && n<=25);
    const s = nums.reduce((a,b)=>a+b,0);
    map[s] = (map[s]||0)+1;
  });
  return Object.entries(map)
    .map(([k,v])=>({ soma:Number(k), count:v }))
    .sort((a,b)=>b.count-a.count);
}

function calcBlockPatternDistribution(concursos){
  const map = {};
  concursos.forEach(c=>{
    const nums=(c.dezenas||[]).map(toNum).filter(n=>n>=1 && n<=25);
    const b = distribuicaoBlocos(nums);
    const key = `${b.A}-${b.B}-${b.C}-${b.D}-${b.E}`;
    map[key]=(map[key]||0)+1;
  });
  return Object.entries(map)
    .map(([k,v])=>{
      const [A,B,C,D,E] = k.split("-").map(Number);
      return { A,B,C,D,E, key:k, count:v };
    })
    .sort((a,b)=>b.count-a.count);
}

function calcBlockTotals(concursos){
  const tot = {A:0,B:0,C:0,D:0,E:0};
  concursos.forEach(c=>{
    const nums=(c.dezenas||[]).map(toNum).filter(n=>n>=1 && n<=25);
    const b=distribuicaoBlocos(nums);
    tot.A+=b.A; tot.B+=b.B; tot.C+=b.C; tot.D+=b.D; tot.E+=b.E;
  });
  return tot;
}

function calcTopPairsCooc(concursos, topN=12){
  const co = Array.from({length:26}, ()=>Array(26).fill(0));
  concursos.forEach(c=>{
    const nums=(c.dezenas||[]).map(toNum).filter(n=>n>=1 && n<=25).sort((a,b)=>a-b);
    for(let i=0;i<nums.length;i++){
      for(let j=i+1;j<nums.length;j++){
        const a=nums[i], b=nums[j];
        co[a][b]++; co[b][a]++;
      }
    }
  });
  const arr=[];
  for(let a=1;a<=25;a++){
    for(let b=a+1;b<=25;b++){
      arr.push({a,b,count:co[a][b]});
    }
  }
  arr.sort((x,y)=>y.count-x.count);
  return arr.slice(0, topN);
}

function renderEvenOddDist(patterns, total){
  const top = (patterns || []).slice(0, 6);
  const max = top[0]?.count || 1;

  const rows = top.map(p=>{
    const pctBar = Math.round((p.count / max) * 100);
    const pctJanela = Math.round((p.count / Math.max(1,total)) * 100);

    return `
      <div style="display:flex;align-items:center;gap:10px;margin:10px 0">
        <div style="width:220px" class="mini">
          <b>${p.pares} pares / ${p.impares} √≠mpares</b><br/>
          <span class="mini" style="margin:0;opacity:.9">${pctJanela}% na janela</span>
        </div>

        <div style="flex:1;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.12);
                    border-radius:999px;overflow:hidden;height:16px">
          <div style="height:100%;width:${pctBar}%;background:linear-gradient(90deg,var(--accent),var(--orange))"></div>
        </div>

        <div style="width:60px;text-align:right;color:var(--text);font-weight:950">${p.count}x</div>
      </div>
    `;
  }).join("");

  const dominante = patterns?.[0]
    ? `<div class="mini" style="margin-top:10px">üî• Dominante: <b>${patterns[0].pares} pares / ${patterns[0].impares} √≠mpares</b> (${patterns[0].count} ocorr√™ncias)</div>`
    : "";

  return `
    <div class="box" style="margin-top:12px">
      <b>‚öñÔ∏è Padr√µes de distribui√ß√£o (equil√≠brio)</b>
      <div class="mini" style="margin-top:6px">
        Gr√°fico das distribui√ß√µes mais recorrentes na janela analisada.
      </div>

      <div style="margin-top:10px">
        ${rows || `<div class="mini">‚Äî</div>`}
      </div>

      ${dominante}
    </div>
  `;
}

function renderSumsTop(sums, total){
  const top = sums.slice(0,7);
  const max = top[0]?.count || 1;
  const rows = top.map(x=>{
    const pct = Math.round((x.count/max)*100);
    const pct2 = Math.round((x.count/Math.max(1,total))*100);
    return `
      <div style="display:flex;align-items:center;gap:10px;margin:10px 0">
        <div style="width:90px;color:var(--text);font-weight:950">Soma ${x.soma}</div>
        <div style="flex:1;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.12);border-radius:999px;overflow:hidden;height:16px">
          <div style="height:100%;width:${pct}%;background:linear-gradient(90deg,var(--accent),var(--orange))"></div>
        </div>
        <div style="width:82px;text-align:right;color:var(--text);font-weight:950">${x.count}x</div>
        <div class="mini" style="margin:0;width:46px;text-align:right">${pct2}%</div>
      </div>
    `;
  }).join("");
  return `
    <div class="box" style="margin-top:12px">
      <b>‚ûï Somas que mais se repetiram</b>
      <div class="mini" style="margin-top:6px">Ajuda a evitar combina√ß√µes muito fora do padr√£o.</div>
      <div style="margin-top:10px">${rows || `<div class="mini">‚Äî</div>`}</div>
    </div>
  `;
}

function renderBlocksPrime(totals, patterns, total){
  // ‚úÖ Mostra SOMENTE: "Padr√µes mais frequentes (A‚ÄìE por concurso)"
  // ‚úÖ (Removeu o gr√°fico de totais A‚ÄìE)

  const toplist = (patterns || []).slice(0, 10); // Top 10 padr√µes
  const maxCount = Math.max(...toplist.map(p => p.count || 0), 1);

  const rows = toplist.map(p => {
    const pctBar = Math.round(((p.count || 0) / maxCount) * 100);
    const pctJanela = Math.round(((p.count || 0) / Math.max(1, total)) * 100);

    return `
      <div style="display:flex;align-items:center;gap:10px;margin:10px 0">
        <div style="width:210px" class="mini">
          <b>Padr√£o:</b>
          <span class="mono">${p.A}-${p.B}-${p.C}-${p.D}-${p.E}</span>
        </div>

        <div style="flex:1;background:rgba(255,255,255,.10);border:1px solid rgba(255,255,255,.12);
                    border-radius:999px;overflow:hidden;height:16px">
          <div style="height:100%;width:${pctBar}%;background:linear-gradient(90deg,var(--accent),var(--orange))"></div>
        </div>

        <div style="width:110px;text-align:right" class="mini">
          <b>${p.count || 0}x</b> ‚Ä¢ ${pctJanela}%
        </div>
      </div>
    `;
  }).join("");

  return `
    <div class="box" style="margin-top:12px">
      <b>üìå Padr√µes mais frequentes (A‚ÄìE por concurso)</b>
      <div class="mini" style="margin-top:6px">
        Cada padr√£o representa quantas dezenas ca√≠ram em cada bloco:
        A(01‚Äì05), B(06‚Äì10), C(11‚Äì15), D(16‚Äì20), E(21‚Äì25).
      </div>

      <div style="margin-top:10px">
        ${rows || `<div class="mini">‚Äî</div>`}
      </div>
    </div>
  `;
}
/* =========================
   ‚úÖ NOVO: conjuntos que mais saem juntos (3..6 dezenas)
========================= */
function combosKFromSorted(arr, k){
  const res = [];
  const n = arr.length;
  function rec(start, path){
    if(path.length === k){ res.push(path.slice()); return; }
    for(let i=start;i<n;i++){
      path.push(arr[i]);
      rec(i+1, path);
      path.pop();
    }
  }
  rec(0, []);
  return res;
}

/**
 * calcTopSetsCooc
 * - acha os conjuntos (k) que aparecem juntos em v√°rios concursos
 * - padr√£o: k=3..6 (ternos, quadras, quintetos, sextetos)
 * - minCount: m√≠nimo de ocorr√™ncias para aparecer na lista
 * - limit: quantos resultados mostrar
 */
function calcTopSetsCooc(concursos, opts={}){
  const {
    minK = 3,
    maxK = 6,
    minCount = 2,
    limit = 12
  } = opts;

  const total = (concursos || []).length;
  const map = new Map(); // key => count

  for(const c of (concursos || [])){
    const nums = (c.dezenas || [])
      .map(toNum)
      .filter(n=>n>=1 && n<=25)
      .sort((a,b)=>a-b);

    if(nums.length < minK) continue;

    const upper = Math.min(maxK, nums.length);
    for(let k=minK;k<=upper;k++){
      const combs = combosKFromSorted(nums, k);
      for(const comb of combs){
        const key = comb.map(format2).join("-");
        map.set(key, (map.get(key) || 0) + 1);
      }
    }
  }

  const list = [];
  for(const [key, count] of map.entries()){
    if(count >= minCount){
      const size = key.split("-").length;
      list.push({ key, count, size });
    }
  }

  // ordena: mais ocorr√™ncias primeiro; empate -> maior tamanho; empate -> alfab√©tico
  list.sort((a,b)=>(b.count-a.count) || (b.size-a.size) || a.key.localeCompare(b.key));

  return { total, list: list.slice(0, limit) };
}

function renderTopSets(setsInfo){
  const total = setsInfo?.total || 0;
  const list = setsInfo?.list || [];

  const rows = list.map(s=>{
    const pct = total ? Math.round((s.count/total)*100) : 0;
    return `
      <tr>
        <td class="mono"><b>${s.key.replaceAll("-", ", ")}</b></td>
        <td>${s.size}</td>
        <td><b>${s.count}</b>x</td>
        <td>${pct}%</td>
      </tr>
    `;
  }).join("");

  return `
    <div class="box" style="margin-top:12px">
      <b>üîó Dezenas que mais saem juntas (conjuntos repetidos)</b>
      <div class="mini" style="margin-top:6px">
        Aqui o sistema busca <b>ternos, quadras, quintetos e sextetos</b> que se repetem na janela selecionada.
        (N√£o √© s√≥ par.)
      </div>
      <div style="margin-top:10px;overflow:auto">
        <table class="table">
          <thead>
            <tr>
              <th>Conjunto</th><th>Tamanho</th><th>Juntos</th><th>% na janela</th>
            </tr>
          </thead>
          <tbody>
            ${rows || `<tr><td colspan="4" class="mini">‚Äî</td></tr>`}
          </tbody>
        </table>
      </div>
      <div class="mini" style="margin-top:10px">
        Dica PRIME: esses conjuntos podem ser usados como ‚Äún√∫cleo‚Äù para montar o jogo, porque mostram repeti√ß√£o real dentro do per√≠odo analisado.
      </div>
    </div>
  `;
}

function renderTopPairs(pairs, total){
  const rows = pairs.map(p=>{
    const pct = Math.round((p.count/Math.max(1,total))*100);
    const type = (p.a%2===0 && p.b%2===0) ? "par-par" : (p.a%2===1 && p.b%2===1) ? "√≠mpar-√≠mpar" : "misto";
    return `
      <tr>
        <td class="mono"><b>${format2(p.a)}-${format2(p.b)}</b></td>
        <td>${type}</td>
        <td><b>${p.count}</b>x</td>
        <td>${pct}%</td>
      </tr>
    `;
  }).join("");

  return `
    <div class="box" style="margin-top:12px">
      <b>üîó Dezenas que mais se repetiram juntas (pares mais fortes)</b>
      <div class="mini" style="margin-top:6px">Pares com maior coocorr√™ncia na janela selecionada.</div>
      <div style="margin-top:10px;overflow:auto">
        <table class="table">
          <thead>
            <tr>
              <th>Par</th><th>Tipo</th><th>Juntos</th><th>% na janela</th>
            </tr>
          </thead>
          <tbody>
            ${rows || `<tr><td colspan="4" class="mini">‚Äî</td></tr>`}
          </tbody>
        </table>
      </div>
    </div>
  `;
}
</script>

<script>
/* =========================
   DADOS ONLINE / DEMO
========================= */
const SOURCES = [
  {
    name: "loteriascaixa-api (p√∫blico)",
    latest: "https://loteriascaixa-api.herokuapp.com/api/lotofacil/latest",
    byId: (n)=>`https://loteriascaixa-api.herokuapp.com/api/lotofacil/${n}`,
    adapt: (j)=>({ concurso:Number(j.concurso), data:j.data||"", dezenas:(j.dezenas||[]).map(String) })
  },
  {
    name: "api.guidi.dev.br (fallback)",
    latest: "https://api.guidi.dev.br/loteria/lotofacil/ultimo",
    byId: (n)=>`https://api.guidi.dev.br/loteria/lotofacil/${n}`,
    adapt: (j)=>({ concurso:Number(j.numero), data:j.dataApuracao||"", dezenas:(j.listaDezenas||[]).map(String) })
  }
];

async function tryFetchJson(url){
  const r = await fetch(url, { cache:"no-store" });
  if(!r.ok) throw new Error("HTTP "+r.status);
  return await r.json();
}

async function getOnlineConcursos(qtd){
  let lastErr=null;
  for(const src of SOURCES){
    try{
      const latestRaw = await tryFetchJson(src.latest);
      const latest = src.adapt(latestRaw);
      if(!latest.concurso || !latest.dezenas?.length) throw new Error("Resposta inv√°lida");

      const ultimo = latest.concurso;
      const inicio = Math.max(1, ultimo - qtd + 1);

     const ids = [];
for (let c = inicio; c <= ultimo; c++) ids.push(c);

// busca tudo em paralelo (muito mais r√°pido)
const results = await Promise.allSettled(ids.map(c => tryFetchJson(src.byId(c))));

const concursos = results
  .filter(r => r.status === "fulfilled")
  .map(r => src.adapt(r.value))
  .filter(x => x && x.concurso && x.dezenas && x.dezenas.length);

// garante que veio tudo; se faltou algum, for√ßa fallback para outra fonte
if (concursos.length !== ids.length) throw new Error("API incompleta (faltou concurso).");

return { mode:"online", source:src.name, latest, concursos, inicio, ultimo };
    }catch(e){
      lastErr=e;
    }
  }
  throw lastErr || new Error("Falha online");
}

function buildDemo(qtd){
  const ultimo = 3600;
  const inicio = ultimo - qtd + 1;
  const concursos=[];
  for(let c=inicio;c<=ultimo;c++){
    const dezenas=new Set();
    while(dezenas.size<15) dezenas.add(Math.floor(Math.random()*25)+1);
    concursos.push({ concurso:c, data:"‚Äî", dezenas:[...dezenas].map(n=>format2(n)) });
  }
  const latest = concursos[concursos.length-1];
  return { mode:"demo", source:"Demonstra√ß√£o (offline)", latest, concursos, inicio, ultimo };
}

async function fetchUltimoResultado(){
  let lastErr=null;
  for(const src of SOURCES){
    try{
      const latestRaw = await tryFetchJson(src.latest);
      const latest = src.adapt(latestRaw);
      return { ...latest, source: src.name, mode: "online" };
    }catch(e){
      lastErr=e;
    }
  }
  const demo = buildDemo(1);
  return { ...demo.latest, source:"DEMO", mode:"demo" };
}
</script>

<script>
/* =========================
   Estado global
========================= */
let lastPayload=null;
let cacheBase = { qtd: null, at: 0, payload: null, freq: null, modern: null };
let lastCtx=null;

let lastPrincipalGame=null;
let lastPrincipalMeta=null;

let lastInvertidaGame=null;
let lastTecnicaGames=null;

/* ‚úÖ MANUAL (Principal) */
let manualPrincipalSet = new Set();

/* ‚úÖ 15P manual */
let linesSystem15 = null;
let linesUser15 = null;
let activeLine15 = 4; // come√ßa na linha 5 (em branco)
/* =========================
   SALVAMENTO LOCAL (1 slot por tipo)
========================= */
const SAVE_PACK_KEY = "lf_save_pack_v1";
const SAVE_15P_KEY  = "lf_save_15p_v1";

function saveLocal(key, data){
  localStorage.setItem(key, JSON.stringify({
    at: Date.now(),
    data
  }));
}

function loadLocal(key){
  try{
    const raw = localStorage.getItem(key);
    if(!raw) return null;
    return JSON.parse(raw);
  }catch(e){
    return null;
  }
}

function timeBR(ms){
  try{
    const d = new Date(ms);
    return d.toLocaleString("pt-BR");
  }catch(e){
    return "‚Äî";
  }
}

</script>

<script>
/* =========================
   Base: preparar contexto
========================= */
function qtdSelecionada(){ return Number(document.getElementById("qtdConcursos").value); }

async function prepararContextoBase(qtd){
  setStatus(true,"Carregando concursos‚Ä¶");
  // ‚úÖ cache por 2 minutos
const now = Date.now();
if (cacheBase.payload && cacheBase.qtd === qtd && (now - cacheBase.at) < 120000) {
  lastPayload = cacheBase.payload;
  lastCtx = { freq: cacheBase.freq, modern: cacheBase.modern };
  setStatus(false,"");
  setProgress(0);
  return { payload: lastPayload, freq: lastCtx.freq, modern: lastCtx.modern };
}
  setProgress(12);

  let payload;
  try{
    setStatus(true,"Buscando concursos reais‚Ä¶");
    setProgress(25);
    payload = await getOnlineConcursos(qtd);
  }catch(e){
    payload = buildDemo(qtd);
  }

  // garante ordem crescente
  payload.concursos = payload.concursos.slice().sort((a,b)=>a.concurso-b.concurso);

  setStatus(true,"Calculando an√°lises do per√≠odo‚Ä¶");
  setProgress(62);

  const freq = calcularFrequencias(payload.concursos);
  const modern = calcModernMetrics(payload.concursos);

  lastPayload = payload;
  lastCtx = { freq, modern };

  setStatus(false,"");
  setProgress(0);

  cacheBase = { qtd, at: Date.now(), payload, freq, modern };

  return { payload, freq, modern };
}

function verConcursos(){
  if(!lastPayload){ alert("Gere primeiro uma an√°lise ou jogo para carregar concursos."); return; }
  document.getElementById("listaConcursos").innerHTML = renderListaConcursos(lastPayload.concursos);
  abrirModal();
}
</script>

<script>
/* =========================
   A√á√ÉO: AN√ÅLISE (PRIME COMPLETA + MODERNA)
========================= */
async function acaoAnalise(){
  if(!access.premium){ alert("üîí Gerar an√°lise exige Premium."); return; }

  const qtd = qtdSelecionada();
  try{
    await prepararContextoBase(qtd);
    const payload = lastPayload;
    const {freq, modern} = lastCtx;

    setStatus(true,"Montando resumo PRIME‚Ä¶");
    setProgress(82);

    const evenOdd = calcEvenOddDistribution(payload.concursos);
    const sums = calcSumDistribution(payload.concursos);
    const blockTotals = calcBlockTotals(payload.concursos);
    const blockPatterns = calcBlockPatternDistribution(payload.concursos);
    const topSetsInfo = calcTopSetsCooc(payload.concursos, {
  minK: 3,
  maxK: 9,
  minCount: 2,
  limit: 12
});

    setStatus(false,""); setProgress(0);

    document.getElementById("analiseArea").innerHTML = `
      <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap">
        <div>
          <div style="font-weight:1000;font-size:16px">üìà An√°lise PRIME do per√≠odo selecionado</div>
          <div class="mini">
            Janela: <b>${payload.inicio}</b> a <b>${payload.ultimo}</b> (${payload.concursos.length} concursos)
          </div>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
          <button class="btn btnGhost" type="button" onclick="verConcursos()">üìÖ Ver concursos</button>
        </div>
      </div>

      ${renderEvenOddDist(evenOdd, payload.concursos.length)}
      ${renderSumsTop(sums, payload.concursos.length)}
      ${renderBlocksPrime(blockTotals, blockPatterns, payload.concursos.length)}
      ${renderTop10(freq, payload.concursos.length)}
      ${renderTop10Atrasadas(modern, payload.concursos.length)}
      ${renderTopSets(topSetsInfo)}

      <div class="box" style="margin-top:12px">
        <b>üìå Nota PRIME</b>
        <div class="mini" style="margin-top:8px">
          Este painel usa estat√≠stica (frequ√™ncia, rec√™ncia, tend√™ncia, coocorr√™ncia e padr√µes). Ajuda a montar estrat√©gias,
          mas <b>n√£o existe garantia de premia√ß√£o</b>.
        </div>
      </div>
    `;

    goView("viewAnalise");
  }catch(e){
    setStatus(false,""); setProgress(0);
    document.getElementById("analiseArea").innerHTML = `
      <div class="box">
        <b>‚ö†Ô∏è Erro</b>
        <div class="mini" style="margin-top:8px">${String(e?.message || e)}</div>
      </div>
    `;
    goView("viewAnalise");
  }
}
</script>

<script>
/* =========================
   MANUAL PICK (JOGO PRINCIPAL)
========================= */
function renderPickGrid(selectedSet, lockedSet){
  let html = `<div class="pickGrid" id="pickGridPrincipal">`;
  for(let n=1;n<=25;n++){
    const sel = selectedSet.has(n) ? " sel" : "";
    const lock = lockedSet && lockedSet.has(n) ? " lock" : "";
    html += `<div class="pickCell${sel}${lock}" data-n="${n}">${format2(n)}</div>`;
  }
  html += `</div>`;
  return html;
}

function bindPickGrid(containerId, onClick){
  const root = document.getElementById(containerId);
  if(!root) return;
  root.querySelectorAll(".pickCell").forEach(cell=>{
    cell.addEventListener("click", ()=>{
      if(cell.classList.contains("lock")) return;
      const n = Number(cell.getAttribute("data-n"));
      onClick(n);
    });
  });
}

function renderManualPrincipalUI(){
  const area = document.getElementById("manualPrincipalArea");
  if(!area) return;

  const selected = [...manualPrincipalSet].sort((a,b)=>a-b);

  area.innerHTML = `
    <div class="box" style="margin-top:12px">
      <b>üß© Monte seu jogo manual (vira o Jogo Principal)</b>
      <div class="mini" style="margin-top:6px">
        Marque <b>15 dezenas</b>. Ao confirmar, a Invertida e a T√©cnica usar√£o o seu jogo.
      </div>

      <div class="numbers" style="justify-content:flex-start;margin-top:10px">
        ${selected.length ? selected.map(n=>`<div class="ball">${format2(n)}</div>`).join("") : `<div class="mini">‚Äî</div>`}
      </div>

      <div class="mini" style="margin-top:8px">
        Selecionadas: <b>${selected.length}/15</b>
      </div>

      ${renderPickGrid(manualPrincipalSet)}

      <div class="row" style="margin-top:12px">
        <div class="col">
          <button class="btn btnGhost" type="button" onclick="manualPrincipalSet=new Set();renderManualPrincipalUI()">Limpar</button>
        </div>
        <div class="col">
          <button class="btn btnPrimary" type="button" onclick="usarManualComoPrincipal()">Usar meu jogo</button>
        </div>
      </div>

      <div class="mini" style="margin-top:10px">
        Dica PRIME: tente manter equil√≠brio de distribui√ß√£o (pares/√≠mpares) e evitar concentra√ß√£o em um √∫nico bloco.
      </div>
    </div>
  `;

  bindPickGrid("pickGridPrincipal", (n)=>{
    if(manualPrincipalSet.has(n)) manualPrincipalSet.delete(n);
    else{
      if(manualPrincipalSet.size>=15) return alert("Voc√™ j√° marcou 15 dezenas.");
      manualPrincipalSet.add(n);
    }
    renderManualPrincipalUI();
  });
}

function usarManualComoPrincipal(){
  if(manualPrincipalSet.size !== 15){
    return alert("Marque exatamente 15 dezenas.");
  }
  const jogo = [...manualPrincipalSet].sort((a,b)=>a-b);

  lastPrincipalGame = jogo.slice();
  lastInvertidaGame = null;
  lastTecnicaGames = null;

  // recalcula meta (se j√° tem contexto carregado)
  if(lastPayload && lastCtx?.freq){
    const freq = lastCtx.freq;
    const cls = classificarDezenas(freq, jogo);
    const pi = contarParesImpares(jogo);
    const soma = somaDezenas(jogo);
    const seq = contarSequencias(jogo);
    const blocos = distribuicaoBlocos(jogo);
    const reps = repetidasDoUltimo(jogo, lastPayload.latest.dezenas);
    lastPrincipalMeta = { cls, pi, soma, seq, blocos, reps };
  }

  alert("‚úÖ Seu jogo foi definido como Jogo Principal!");
  updateCheckButtons();
}
</script>

<script>
/* =========================
   A√á√ÉO: JOGO PRINCIPAL (PRIME + MODERNO + MANUAL)
========================= */
async function acaoPrincipal(){
  const qtd = qtdSelecionada();

  if(!access.premium && isFreeUsed()){
    alert("üîí Voc√™ j√° usou a gera√ß√£o gr√°tis. Para liberar, ative o Premium.");
    return;
  }

  try{
    await prepararContextoBase(qtd);
    const payload = lastPayload;
    const {freq, modern} = lastCtx;

    setStatus(true,"Gerando jogo principal (15 dezenas)‚Ä¶");
    setProgress(80);

    const result = gerarJogoPrincipalPrime(freq, modern, payload.concursos, payload.latest.dezenas);
const jogo = result.jogo;

    lastPrincipalGame = jogo.slice();
    lastInvertidaGame = null;
    lastTecnicaGames = null;

    const cls = classificarDezenas(freq, jogo);
    const pi = contarParesImpares(jogo);
    const soma = somaDezenas(jogo);
    const seq = contarSequencias(jogo);
    const blocos = distribuicaoBlocos(jogo);
    const reps = repetidasDoUltimo(jogo, payload.latest.dezenas);

    lastPrincipalMeta = { cls, pi, soma, seq, blocos, reps };

    setStatus(false,""); setProgress(0);

    if(!access.premium) markFreeUsed();
    aplicarAcessos();

    const balls = jogo.map(n=>`<div class="ball">${format2(n)}</div>`).join("");
// ‚úÖ AGRUPA motivos iguais para ocupar menos espa√ßo
const motivosAgrupados = {};
(result?.motivos || []).forEach(m=>{
  const key = (m.texto || "").trim();
  if(!motivosAgrupados[key]) motivosAgrupados[key] = [];
  motivosAgrupados[key].push(m.dezena);
});

const motivosHtml = Object.entries(motivosAgrupados)
  .sort((a,b)=>a[1][0]-b[1][0])
  .map(([texto, dezenas])=>{
    const lista = dezenas.sort((x,y)=>x-y).map(n=>format2(n)).join(", ");
    return `
      <div style="padding:10px;border-bottom:1px solid rgba(255,255,255,.08)">
        <b class="mono">${lista}</b>
        <div class="mini" style="margin-top:6px">${texto}</div>
      </div>
    `;
  }).join("") || `<div class="mini">‚Äî</div>`;

    const resumoPares = (pi.pares===7||pi.pares===8)
      ? `Distribui√ß√£o ideal (${pi.pares} pares / ${pi.impares} √≠mpares).`
      : `Distribui√ß√£o fora do ideal (melhor: 7/8).`;
    const resumoSoma = (soma>=170 && soma<=230)
      ? `Soma ${soma} dentro da faixa estat√≠stica mais comum (evita extremos).`
      : `Soma ${soma} fora da faixa mais comum ‚Äî combina√ß√£o mais ‚Äúarriscada‚Äù.`;
    const resumoSeq = seq.temSequencia
      ? `Possui sequ√™ncia, m√°ximo de ${seq.maxLen} n√∫meros seguidos.`
      : `Sem sequ√™ncia (padr√£o mais ‚Äúquebrado‚Äù).`;
    const maxBlock = Math.max(blocos.A,blocos.B,blocos.C,blocos.D,blocos.E);
    const resumoBlocos = (maxBlock<=5)
      ? `Blocos equilibrados (m√°x ${maxBlock} em um bloco).`
      : `Concentra√ß√£o alta em blocos (m√°x ${maxBlock}).`;
    const resumoRep = reps.length
      ? `${reps.length} repetidas do √∫ltimo concurso (${payload.latest.concurso}).`
      : `Sem repetidas do √∫ltimo concurso (${payload.latest.concurso}).`;

    document.getElementById("principalArea").innerHTML = `
      <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap">
        <div>
          <div style="font-weight:1000;font-size:16px">üéØ Jogo Principal gerado (15 dezenas)</div>
          <div class="mini">Janela: <b>${payload.inicio}</b> a <b>${payload.ultimo}</b> (${payload.concursos.length} concursos)</div>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
  <button class="btn btnGhost" type="button" onclick="verConcursos()">üìÖ Ver concursos</button>
  <button class="btn btnGhost" type="button" onclick="abrirGraficoBlocos(lastPrincipalMeta.blocos)">üìä Blocos A‚ÄìE</button>

  <button class="btn btnBlue" type="button" onclick="salvarPacotePrincipal()">üíæ Salvar pacote</button>
  <button class="btn btnGhost" type="button" onclick="carregarPacotePrincipal()">üìÇ Carregar salvo</button>
</div>
      </div>

      <div class="numbers">${balls}</div>
<div class="box" style="margin-top:12px">
  <b>üßæ Por que essas dezenas foram escolhidas?</b>
  <div class="mini" style="margin-top:8px">
    Explica√ß√£o do m√©todo: o sistema classifica dezenas por comportamento (letras A‚ÄìH) na janela N e aplica um TEMPLATE FIXO do Principal (quotas + repetidas alvo + paridade dominante) para prever o pr√≥ximo concurso.
  </div>
  <div style="margin-top:10px;border:1px solid rgba(255,255,255,.10);border-radius:14px;overflow:hidden">
    ${motivosHtml}
  </div>
</div>

      <div class="box" style="margin-top:12px">
        <b>üßæ Resumo PRIME (detalhado)</b>
        <div class="grid gridExplain" style="margin-top:12px">
          
          <div class="box">
            <b>üîÅ Repetidas do √∫ltimo</b>
            <div class="mini" style="margin-top:8px"><b>${reps.length ? reps.map(format2).join(", ") : "Nenhuma"}</b></div>
            <div class="mini">${resumoRep}</div>
          </div>

          <div class="box">
            <b>‚öñÔ∏è Pares x √çmpares</b>
            <div class="mini" style="margin-top:8px"><b>${pi.pares}</b> pares ‚Ä¢ <b>${pi.impares}</b> √≠mpares</div>
            <div class="mini">${resumoPares}</div>
          </div>

          <div class="box">
            <b>‚ûï Soma</b>
            <div class="mini" style="margin-top:8px"><b>${soma}</b></div>
            <div class="mini">${resumoSoma}</div>
          </div>

          <div class="box">
            <b>üß© Blocos A‚ÄìE</b>
            <div class="mini" style="margin-top:8px">A: <b>${blocos.A}</b> ‚Ä¢ B: <b>${blocos.B}</b> ‚Ä¢ C: <b>${blocos.C}</b> ‚Ä¢ D: <b>${blocos.D}</b> ‚Ä¢ E: <b>${blocos.E}</b></div>
            <div class="mini">${resumoBlocos}</div>
          </div>

          <div class="box">
            <b>üîó Sequ√™ncias</b>
            <div class="mini" style="margin-top:8px"><b>${seq.temSequencia ? "Sim" : "N√£o"}</b> ‚Ä¢ M√°x: <b>${seq.maxLen}</b></div>
            <div class="mini">${resumoSeq}</div>
          </div>
        </div>
      </div>

      <div class="grid" style="margin-top:12px">
        <div class="box">
          <b>ü§ñ Jogo do Sistema (atual)</b>
          <div class="numbers" style="justify-content:flex-start;margin-top:10px">${jogo.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
          <div class="mini">Voc√™ pode usar este ou montar o seu jogo manual e substituir o principal.</div>
        </div>
        <div class="box">
          <div id="manualPrincipalArea"></div>
        </div>
      </div>

      <div class="panelCheck" id="panelGerados">
        <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
          <b>‚úÖ Verificar jogos gerados (base: Jogo Principal)</b>
          <button class="btn btnGhost" type="button" id="btnVerificarGeradosInline" style="display:none" onclick="goView('viewCheck')">Abrir verifica√ß√£o</button>
        </div>
        <div class="mini" style="margin-top:8px">
          Gere tamb√©m a <b>Invertida</b> e a <b>T√©cnica</b> para liberar a verifica√ß√£o autom√°tica de acertos.
        </div>
      </div>

      <div class="box" style="margin-top:12px">
        <b>üìå Aviso</b>
        <div class="mini" style="margin-top:8px">
          Estat√≠stica ajuda a montar estrat√©gia, mas <b>n√£o garante premia√ß√£o</b>.
        </div>
      </div>
    `;

    goView("viewPrincipal");

    // reset sele√ß√£o manual para o usu√°rio come√ßar ‚Äúdo zero‚Äù
    manualPrincipalSet = new Set();
    renderManualPrincipalUI();

    updateCheckButtons();
  }catch(e){
    setStatus(false,""); setProgress(0);
    document.getElementById("principalArea").innerHTML = `
      <div class="box">
        <b>‚ö†Ô∏è Erro</b>
        <div class="mini" style="margin-top:8px">${String(e?.message || e)}</div>
      </div>
    `;
    goView("viewPrincipal");
  }
}
</script>

<script>
function salvarPacotePrincipal(){
  if(!lastPrincipalGame){
    alert("Gere um Jogo Principal primeiro.");
    return;
  }

  // pacote completo (principal + invertida + t√©cnica)
  const pack = {
    principal: lastPrincipalGame || null,
    invertida: lastInvertidaGame || null,
    tecnica1: lastTecnicaGames?.g1 || null,
    tecnica2: lastTecnicaGames?.g2 || null,
    window: lastPayload ? { inicio:lastPayload.inicio, ultimo:lastPayload.ultimo, qtd:lastPayload.concursos?.length || null } : null
  };

  saveLocal(SAVE_PACK_KEY, pack);
  // Salva tamb√©m como item fixo em "JOGOS SALVOS"
salvarJogoNoStorage({
  slot: "Principal+Invertida+Tecnica",
  tipo: "pack",
  nome: "Principal+Invertida+Tecnica",
  pack: pack,
  at: Date.now()
});

alert("‚úÖ Pacote salvo em JOGOS SALVOS: Principal+Invertida+Tecnica (sobrescreve ao salvar de novo)");
}

function carregarPacotePrincipal(){
  const saved = loadLocal(SAVE_PACK_KEY);
  if(!saved?.data){
    alert("N√£o existe pacote salvo ainda.");
    return;
  }

  const p = saved.data;

  lastPrincipalGame = Array.isArray(p.principal) ? p.principal.slice() : null;
  lastInvertidaGame = Array.isArray(p.invertida) ? p.invertida.slice() : null;

  if(p.tecnica1 && p.tecnica2){
    lastTecnicaGames = { g1: p.tecnica1.slice(), g2: p.tecnica2.slice() };
  }else{
    lastTecnicaGames = null;
  }

  updateCheckButtons();

  alert("‚úÖ Pacote carregado! Salvo em: " + timeBR(saved.at));
}
/* =========================
   INVERTIDA + T√âCNICA
========================= */
// ‚úÖ MAPEAMENTO POR COLUNA (cart√£o DEITADO / vertical)
// blocoIndex = COLUNA (1..5), offsetNoBloco = LINHA (1..5)
function blocoIndex(n){ return ((n-1)%5)+1; }
function offsetNoBloco(n){ return Math.floor((n-1)/5)+1; }
function mapParaBloco(destBloco, offset){ return (offset-1)*5 + destBloco; }

function remapPorPermutacao(n, perm){
  const b = blocoIndex(n);
  const off = offsetNoBloco(n);
  const destB = perm[b-1];
  return mapParaBloco(destB, off);
}
function inverterJogoPorPerm(jogo, perm){
  return jogo.map(n=>remapPorPermutacao(Number(n), perm)).sort((a,b)=>a-b);
}
function renderCartao(jogo, clsName){
  const set = new Set(jogo.map(Number));
  let html = `<div class="cartao">`;
  for(let n=1;n<=25;n++){
    const active = set.has(n) ? ` ${clsName}` : "";
    html += `<div class="cel${active}">${String(n).padStart(2,"0")}</div>`;
  }
  html += `</div>`;
  return html;
}

async function gerarInvertida(silent=false){
  if(!access.premium){
    if(!silent) alert("üîí Invertida exige Premium.");
    return;
  }

  const area = document.getElementById("invertidaArea");

  try{
    // garante contexto carregado (usa a janela selecionada)
    const qtd = qtdSelecionada();
    await prepararContextoBase(qtd);

    const payload = lastPayload;
    const {freq, modern} = lastCtx;

    const latest = (payload?.latest?.dezenas || []).map(toNum).filter(n=>n>=1&&n<=25).sort((a,b)=>a-b);
    if(latest.length !== 15){
      if(area) area.innerHTML = `<div class="box"><b>‚ö†Ô∏è</b><div class="mini" style="margin-top:8px">N√£o foi poss√≠vel obter o √∫ltimo concurso (15 dezenas).</div></div>`;
      return;
    }

    const latestSet = new Set(latest);
    const all = Array.from({length:25},(_,i)=>i+1);
    const outPool = all.filter(n=>!latestSet.has(n));
    const concursos = payload.concursos || [];

    // Evita repetir MUITO do Principal (se existir)
    let avoidIn = new Set();
    let avoidOut = new Set();
    if(Array.isArray(lastPrincipalGame) && lastPrincipalGame.length===15){
      const sp = splitInOutByLatest(lastPrincipalGame, latest);
      avoidIn = new Set(sp.inLast);
      avoidOut = new Set(sp.outLast);
    }

    // ‚úÖ NOVA REGRA:
    // INVERTIDA = 9 do √∫ltimo + 6 fora (grupos que mais saem juntos),
    // com desempate para diversificar do Principal.
    const inBest  = bestSubsetFromPool(latest, 9, concursos, freq, modern, avoidIn);
    const outBest = bestSubsetFromPool(outPool, 6, concursos, freq, modern, avoidOut);

    const inv = [...inBest, ...outBest].sort((a,b)=>a-b);
    lastInvertidaGame = inv.slice();

    const motivos = [];
    inBest.forEach(n=>motivos.push({ dezena:n, texto:"‚ôªÔ∏è Veio do √∫ltimo concurso (grupo forte)" }));
    outBest.forEach(n=>motivos.push({ dezena:n, texto:"üÜï N√£o veio no √∫ltimo concurso (grupo forte)" }));

    const togetherIn  = countGroupTogetherInWindow(inBest, concursos);
    const togetherOut = countGroupTogetherInWindow(outBest, concursos);
    motivos.push({
      dezena: inv[0],
      texto: `üìå Regra PREMIUM: 9 do √∫ltimo + 6 fora ‚Ä¢ Janela: ${concursos?.length||0} concursos ‚Ä¢ 'Juntos' (9): ${togetherIn} ‚Ä¢ 'Juntos' (6): ${togetherOut}`
    });

    const balls = inv.map(n=>`<div class="ball">${format2(n)}</div>`).join("");

    const motivosAgrupados = {};
    (motivos||[]).forEach(m=>{
      const key = (m.texto||"").trim();
      if(!motivosAgrupados[key]) motivosAgrupados[key]=[];
      if(Number.isFinite(m.dezena)) motivosAgrupados[key].push(m.dezena);
    });
    const motivosHtml = Object.entries(motivosAgrupados).map(([k,arr])=>{
      const nums = arr.sort((a,b)=>a-b).map(format2).join(" - ");
      return `<div class="mini">‚Ä¢ <b>${k}</b>${nums?`<br><span style="opacity:.9">${nums}</span>`:""}</div>`;
    }).join("");

    if(area){
      area.innerHTML = `
        <div class="box">
          <b>üîÑ Invertida PREMIUM (9 do √∫ltimo + 6 fora)</b>
          <div class="numbers" style="justify-content:flex-start">${balls}</div>
          <div style="margin-top:10px">${motivosHtml}</div>
        </div>
      `;
    }

    updateCheckButtons();
  }catch(e){
    if(area) area.innerHTML = `<div class="box"><b>‚ö†Ô∏è Erro</b><div class="mini" style="margin-top:8px">${String(e?.message||e)}</div></div>`;
  }
}


async function gerarTecnicaPremiada(silent=false){
  if(!access.premium){
    if(!silent) alert("üîí T√©cnica premiada exige Premium.");
    return;
  }

  const area = document.getElementById("tecnicaArea");

  try{
    const qtd = qtdSelecionada();
    await prepararContextoBase(qtd);

    const payload = lastPayload;
    const {freq, modern} = lastCtx;

    const latest = (payload?.latest?.dezenas || []).map(toNum).filter(n=>n>=1&&n<=25).sort((a,b)=>a-b);
    if(latest.length !== 15){
      if(area) area.innerHTML = `<div class="box"><b>‚ö†Ô∏è</b><div class="mini" style="margin-top:8px">N√£o foi poss√≠vel obter o √∫ltimo concurso (15 dezenas).</div></div>`;
      return;
    }

    const latestSet = new Set(latest);
    const all = Array.from({length:25},(_,i)=>i+1);
    const outPool = all.filter(n=>!latestSet.has(n));
    const concursos = payload.concursos || [];

    // Evita repetir entre os 4 jogos (desempate)
    const avoidAll = new Set();
    const addAll = (arr)=>{ (arr||[]).forEach(n=>avoidAll.add(toNum(n))); };

    // Se o usu√°rio definiu Principal manualmente, respeitamos ele como "jogo 1" para diversifica√ß√£o
    addAll(lastPrincipalGame);
    addAll(lastInvertidaGame);

    // ===== T√âCNICA JOGO 1: 10 do √∫ltimo + 5 fora =====
    const avoidIn1 = new Set([...avoidAll].filter(n=>latestSet.has(n)));
    const avoidOut1 = new Set([...avoidAll].filter(n=>!latestSet.has(n)));

    const in1  = bestSubsetFromPool(latest, 10, concursos, freq, modern, avoidIn1);
    const out1 = bestSubsetFromPool(outPool, 5, concursos, freq, modern, avoidOut1);
    const g1 = [...in1, ...out1].sort((a,b)=>a-b);

    // Atualiza avoid para o jogo 2 n√£o "colar" no jogo 1
    addAll(g1);

    // ===== T√âCNICA JOGO 2: 9 do √∫ltimo + 6 fora =====
    const avoidIn2 = new Set([...avoidAll].filter(n=>latestSet.has(n)));
    const avoidOut2 = new Set([...avoidAll].filter(n=>!latestSet.has(n)));

    const in2  = bestSubsetFromPool(latest, 9, concursos, freq, modern, avoidIn2);
    const out2 = bestSubsetFromPool(outPool, 6, concursos, freq, modern, avoidOut2);
    const g2 = [...in2, ...out2].sort((a,b)=>a-b);

    lastTecnicaGames = { g1: g1.slice(), g2: g2.slice() };

    const makeMotivos = (inBest, outBest, label)=>{
      const m = [];
      inBest.forEach(n=>m.push({ dezena:n, texto:"‚ôªÔ∏è Veio do √∫ltimo concurso (grupo forte)" }));
      outBest.forEach(n=>m.push({ dezena:n, texto:"üÜï N√£o veio no √∫ltimo concurso (grupo forte)" }));
      const tIn  = countGroupTogetherInWindow(inBest, concursos);
      const tOut = countGroupTogetherInWindow(outBest, concursos);
      m.push({ dezena: (inBest[0]||outBest[0]||1), texto: `üìå ${label} ‚Ä¢ Janela: ${concursos?.length||0} concursos ‚Ä¢ 'Juntos': ${tIn} / ${tOut}` });
      return m;
    };

    const motivos1 = makeMotivos(in1, out1, "T√âCNICA 1 = 10 do √∫ltimo + 5 fora");
    const motivos2 = makeMotivos(in2, out2, "T√âCNICA 2 = 9 do √∫ltimo + 6 fora");

    const renderBox = (titulo, jogo, motivos)=>{
      const balls = jogo.map(n=>`<div class="ball">${format2(n)}</div>`).join("");
      const agrup = {};
      (motivos||[]).forEach(m=>{
        const key=(m.texto||"").trim();
        if(!agrup[key]) agrup[key]=[];
        if(Number.isFinite(m.dezena)) agrup[key].push(m.dezena);
      });
      const motivosHtml = Object.entries(agrup).map(([k,arr])=>{
        const nums = arr.sort((a,b)=>a-b).map(format2).join(" - ");
        return `<div class="mini">‚Ä¢ <b>${k}</b>${nums?`<br><span style="opacity:.9">${nums}</span>`:""}</div>`;
      }).join("");

      return `
        <div class="box" style="margin-bottom:12px">
          <b>${titulo}</b>
          <div class="numbers" style="justify-content:flex-start">${balls}</div>
          <div style="margin-top:10px">${motivosHtml}</div>
        </div>
      `;
    };

    if(area){
      area.innerHTML = `
        ${renderBox("üèÜ T√©cnica Jogo 1 (10 do √∫ltimo + 5 fora)", g1, motivos1)}
        ${renderBox("üèÜ T√©cnica Jogo 2 (9 do √∫ltimo + 6 fora)", g2, motivos2)}
      `;
    }

    updateCheckButtons();
  }catch(e){
    if(area) area.innerHTML = `<div class="box"><b>‚ö†Ô∏è Erro</b><div class="mini" style="margin-top:8px">${String(e?.message||e)}</div></div>`;
  }
}


/* mostra bot√µes de verifica√ß√£o quando tiver Principal + Invertida + T√©cnica */
function updateCheckButtons(){
  const ready = !!(lastPrincipalGame && lastInvertidaGame && lastTecnicaGames?.g1 && lastTecnicaGames?.g2);

  const btnTop = document.getElementById("btnVerificarGeradosFromPrincipal");
  const btnInline = document.getElementById("btnVerificarGeradosInline");

  if(btnTop) btnTop.style.display = ready ? "inline-flex" : "none";
  if(btnInline) btnInline.style.display = ready ? "inline-flex" : "none";

  const panel = document.getElementById("panelGerados");
  if(panel){
    panel.querySelector(".mini").innerHTML = ready
      ? `Pronto ‚úÖ Agora voc√™ pode conferir automaticamente os <b>4 jogos gerados</b> (Principal, Invertida, T√©cnica 1 e T√©cnica 2) com base no resultado do concurso.`
      : `Gere tamb√©m a <b>Invertida</b> e a <b>T√©cnica</b> para liberar a verifica√ß√£o autom√°tica de acertos.`;
  }

  if(ready){
    montarTelaCheck();
  }
}

async function conferirGerados(){
  if(!(lastPrincipalGame && lastInvertidaGame && lastTecnicaGames?.g1 && lastTecnicaGames?.g2)){
    alert("Gere Principal + Invertida + T√©cnica primeiro.");
    return;
  }

  let res;
  try{
    res = await fetchUltimoResultado();
  }catch(e){
    alert("Falha ao buscar o √∫ltimo resultado.");
    return;
  }
  const resultNums = (res.dezenas||[]).map(toNum);

  function hits(gameNums){
    const setR=new Set(resultNums);
    const h = sortNum(gameNums.filter(n=>setR.has(Number(n))).map(Number));
    return {count:h.length, hits:h};
  }

  const hP = hits(lastPrincipalGame);
  const hI = hits(lastInvertidaGame);
  const hT1 = hits(lastTecnicaGames.g1);
  const hT2 = hits(lastTecnicaGames.g2);

  document.getElementById("checkArea").innerHTML = `
    <div class="box">
      <b>üìå Resultado usado para confer√™ncia</b>
      <div class="mini" style="margin-top:8px">
        Concurso <b>${res.concurso}</b> ‚Ä¢ Data: <b>${res.data || "‚Äî"}</b> ‚Ä¢ Dezenas:
        <span class="mono">${resultNums.map(format2).join(" - ")}</span>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="box">
        <b>üéØ Principal ‚Ä¢ Acertos: ${hP.count}</b>
        <div class="mini" style="margin-top:8px">Acertou: <b>${hP.hits.map(format2).join(", ") || "‚Äî"}</b></div>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastPrincipalGame.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>

      <div class="box">
        <b>üîÑ Invertida ‚Ä¢ Acertos: ${hI.count}</b>
        <div class="mini" style="margin-top:8px">Acertou: <b>${hI.hits.map(format2).join(", ") || "‚Äî"}</b></div>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastInvertidaGame.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>

      <div class="box">
        <b>üèÜ T√©cnica 1 ‚Ä¢ Acertos: ${hT1.count}</b>
        <div class="mini" style="margin-top:8px">Acertou: <b>${hT1.hits.map(format2).join(", ") || "‚Äî"}</b></div>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastTecnicaGames.g1.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>

      <div class="box">
        <b>üèÜ T√©cnica 2 ‚Ä¢ Acertos: ${hT2.count}</b>
        <div class="mini" style="margin-top:8px">Acertou: <b>${hT2.hits.map(format2).join(", ") || "‚Äî"}</b></div>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastTecnicaGames.g2.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>
    </div>

    <div class="tinyFoot">Fonte: ${res.source || "‚Äî"} ‚Ä¢ Modo: ${String(res.mode||"‚Äî").toUpperCase()}</div>
  `;
}

function montarTelaCheck(){
  document.getElementById("checkArea").innerHTML = `
    <div class="box">
      <b>‚úÖ Seus 4 jogos gerados (base: Jogo Principal)</b>
      <div class="mini" style="margin-top:8px">
        Clique em <b>‚ÄúConferir com √∫ltimo concurso‚Äù</b> para ver quantos n√∫meros cada jogo acertou.
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="box">
        <b>üéØ Principal</b>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastPrincipalGame.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>
      <div class="box">
        <b>üîÑ Invertida</b>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastInvertidaGame.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>
      <div class="box">
        <b>üèÜ T√©cnica 1</b>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastTecnicaGames.g1.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>
      <div class="box">
        <b>üèÜ T√©cnica 2</b>
        <div class="numbers" style="justify-content:flex-start;margin-top:10px">${lastTecnicaGames.g2.map(n=>`<div class="ball">${format2(n)}</div>`).join("")}</div>
      </div>
    </div>
  `;
}
</script>

<script>
/* =========================
   15P (mais forte + editor manual)
========================= */
function salvar15P(){
  if(!linesSystem15 || !Array.isArray(linesSystem15) || linesSystem15.length !== 5){
    alert("Gere o 15P primeiro.");
    return;
  }

  // salva no slot local (como j√° fazia)
  const data = {
    linesUser15,
    linesSystem15,
    activeLine15
  };
  saveLocal(SAVE_15P_KEY, data);

  // ‚úÖ gera os 10 jogos do SISTEMA (sempre completo)
  const jogosSystem = gerarJogos15P(linesSystem15);

  // ‚úÖ se o usu√°rio completou as 5 linhas manuais, salva tamb√©m os 10 jogos do usu√°rio
  const jogosUser = (typeof allLinesComplete === "function" && allLinesComplete(linesUser15))
    ? gerarJogos15P(linesUser15)
    : null;

  // ‚úÖ salva tamb√©m dentro de "JOGOS SALVOS"
  salvarJogoNoStorage({
    slot: "15 pontos garantidos",
    tipo: "15p",
    nome: "15 pontos garantidos",
    at: Date.now(),
    payload: {
      linesSystem15,
      linesUser15,
      jogosSystem,
      jogosUser
    }
  });

  alert("‚úÖ 15P salvo em JOGOS SALVOS: 15 pontos garantidos (sobrescreve ao salvar de novo)");
}

function carregar15P(){
  const saved = loadLocal(SAVE_15P_KEY);
  if(!saved?.data){
    alert("N√£o existe 15P salvo ainda.");
    return;
  }
  const d = saved.data;

  linesUser15 = (d.linesUser15 || null);
  linesSystem15 = (d.linesSystem15 || null);
  activeLine15 = (typeof d.activeLine15 === "number") ? d.activeLine15 : 4;

  // re-render editor se estiver aberto
  if(document.getElementById("editor15Area")){
    render15Editor();
  }
  alert("‚úÖ 15P carregado! Salvo em: " + timeBR(saved.at));
}
function calcCoocAndStats(concursos){
  const n = concursos.length;
  const freq = Array(26).fill(0);
  const co = Array.from({length:26}, ()=>Array(26).fill(0));

  // rec√™ncia (exponencial)
  const decay = Array(26).fill(0);
  const lastSeen = Array(26).fill(-1);
  const DECAY = 0.92;

  concursos.forEach((c,idx)=>{
    const nums = (c.dezenas||[])
      .map(d=>Number(String(d).replace(/^0+/,"")))
      .filter(x=>x>=1 && x<=25);
    const w = Math.pow(DECAY, (n-1-idx));

    nums.forEach(a=>{
      freq[a]++; decay[a]+=w; lastSeen[a]=idx;
    });

    for(let i=0;i<nums.length;i++){
      for(let j=i+1;j<nums.length;j++){
        const a=nums[i], b=nums[j];
        co[a][b]++; co[b][a]++;
      }
    }
  });

  const p = Array(26).fill(0);
  for(let i=1;i<=25;i++) p[i] = freq[i] / Math.max(1,n);

  const gap = Array(26).fill(999);
  for(let i=1;i<=25;i++){
    gap[i] = (lastSeen[i]===-1) ? n : (n-1-lastSeen[i]);
  }

  const lift = Array.from({length:26}, ()=>Array(26).fill(0));
  for(let a=1;a<=25;a++){
    for(let b=1;b<=25;b++){
      if(a===b) continue;
      const pab = co[a][b] / Math.max(1,n);
      const denom = (p[a] * p[b]);
      lift[a][b] = denom>0 ? (pab/denom) : 0;
    }
  }
  return { n, freq, co, p, lift, decay, gap };
}

function pairStrength(a,b, stats){
  // for√ßa = cooc + lift + rec√™ncia dos n√∫meros
  const {co, lift, decay} = stats;
  const base = (co[a][b] * 1.0) + (lift[a][b] * 2.2);
  const rec = (decay[a] + decay[b]) * 0.55;
  return base + rec;
}

function groupStrength(group, stats){
  let sum=0, pairs=0;
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      sum += pairStrength(group[i], group[j], stats);
      pairs++;
    }
  }
  return { sum, avg: pairs? (sum/pairs):0 };
}

function groupCoSum(group, stats){
  const {co} = stats;
  let sum=0, pairs=0;
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      sum += co[group[i]][group[j]];
      pairs++;
    }
  }
  return { sum, avg: pairs? (sum/pairs):0 };
}

function groupLiftAvg(group, stats){
  const {lift} = stats;
  let sum=0, pairs=0;
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      sum += lift[group[i]][group[j]];
      pairs++;
    }
  }
  return { sum, avg: pairs? (sum/pairs):0 };
}

function groupFreqSum(group, stats){
  const {freq} = stats;
  return group.reduce((a,n)=>a+freq[n],0);
}

function topPairsInGroup(group, stats, topN=3){
  const arr=[];
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      const a=group[i], b=group[j];
      arr.push({ a,b, co: stats.co[a][b], lift: stats.lift[a][b], score: pairStrength(a,b,stats) });
    }
  }
  arr.sort((x,y)=>y.score-x.score);
  return arr.slice(0, topN);
}
function worstPairsInGroup(group, stats, topN=3){
  const arr=[];
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      const a=group[i], b=group[j];
      arr.push({ a,b, co: stats.co[a][b], lift: stats.lift[a][b], score: pairStrength(a,b,stats) });
    }
  }
  arr.sort((x,y)=>x.score-y.score);
  return arr.slice(0, topN);
}

/* ‚úÖ NOVO: constru√ß√£o inicial por score (freq + rec√™ncia + atraso controlado) */
function buildInitialLines(stats){
  const order = [];
  for(let i=1;i<=25;i++){
    // score: frequ√™ncia + rec√™ncia, com b√¥nus leve para atraso (sem exagero)
    const s = (stats.freq[i]*1.0) + (stats.decay[i]*3.0) + Math.min(6, stats.gap[i]*0.35);
    order.push({i, s});
  }
  order.sort((a,b)=>b.s-a.s);

  const lines = [[],[],[],[],[]];
  // distribui√ß√£o round-robin para j√° evitar concentra√ß√£o
  for(let k=0;k<order.length;k++){
    lines[k%5].push(order[k].i);
  }
  lines.forEach(l=>l.sort((a,b)=>a-b));
  return lines;
}

/* ‚úÖ NOVO: penalidades por paridade + bloco + mix de frequ√™ncias */
function objective(lines, stats){
  const scoredLines = lines.map(l=>{
    const st = groupStrength(l, stats).sum;
    const pares = l.filter(n=>n%2===0).length;
    const imp = 5 - pares;
    const blocos = distribuicaoBlocos(l);
    const maxBlock = Math.max(blocos.A,blocos.B,blocos.C,blocos.D,blocos.E);

    // mistura freq (evitar 5 todas muito quentes ou muito frias)
    const fvals = l.map(n=>stats.freq[n]).sort((a,b)=>a-b);
    const spread = (fvals[4]-fvals[0]);

    let penalty=0;
    // paridade ideal na linha: 2/3 ou 3/2
    if(!(pares===2 || pares===3)) penalty += 6;

    // bloco: evitar 4 ou 5 no mesmo bloco
    if(maxBlock>=4) penalty += (maxBlock-3)*10;

    // spread m√≠nimo (mistura) ‚Äî se muito baixo, √© ‚Äútudo igual‚Äù
    if(spread<=1) penalty += 6;

    return { st, penalty };
  });

  // 3 fortes + 2 diversas
  const sorted = scoredLines.slice().sort((a,b)=> (b.st-b.penalty) - (a.st-a.penalty));
  const strong = sorted.slice(0,3).reduce((a,x)=>a+(x.st - x.penalty),0);
  const diverse = sorted.slice(3).reduce((a,x)=>a+(x.st - x.penalty),0);

  // diversidade: queremos 2 linhas com menor cooc e penalty baixo
  return (strong * 1.0) + (diverse * 0.55);
}

function optimizeLines(lines, stats){
  let best = lines.map(l=>l.slice());
  let bestScore = objective(best, stats);

  function clone(x){ return x.map(l=>l.slice()); }
  const ITER = 5200;

  for(let t=0;t<ITER;t++){
    const cand = clone(best);

    const i = Math.floor(Math.random()*5);
    let j = Math.floor(Math.random()*5);
    if(i===j) j = (j+1)%5;

    const ai = Math.floor(Math.random()*5);
    const aj = Math.floor(Math.random()*5);

    const tmp = cand[i][ai];
    cand[i][ai] = cand[j][aj];
    cand[j][aj] = tmp;

    cand[i].sort((a,b)=>a-b);
    cand[j].sort((a,b)=>a-b);

    const sc = objective(cand, stats);
    if(sc > bestScore || Math.random() < 0.02){
      best = cand; bestScore = sc;
    }
  }

  // ordena linhas por for√ßa (para explicar)
  const withScore = best.map((l)=>({l, s: groupStrength(l,stats).sum}));
  withScore.sort((a,b)=>b.s-a.s);

  const strong = withScore.slice(0,3).map(x=>x.l);
  const diverse = withScore.slice(3).map(x=>x.l);

  return strong.concat(diverse);
}



/* ============================================================
   ‚úÖ 15P ‚Äì GERADOR AVAN√áADO (LINHAS POR "SAIU / N√ÉO SAIU")
   - Mant√©m regras: L1 4+1, L2 4+1, L3 1+4, L4 3+2, L5 3+2
   - Usa for√ßa por coocorr√™ncia/lift + regulariza√ß√£o (curto+m√©dio)
   - Crit√©rios de desempate: paridade, blocos/colunas, diversidade (anti-repeti√ß√£o)
   - L4/L5 montadas em conjunto, com baixa correla√ß√£o com L1‚ÄìL3
   ============================================================ */

function numScoreOne(n, stats){
  // score b√°sico do n√∫mero: freq + rec√™ncia (decay) + atraso leve
  return (stats.freq[n]*1.0) + (stats.decay[n]*3.0) + Math.min(6, stats.gap[n]*0.35);
}

function mixPairStrength(a,b, sShort, sMed, wShort, wMed){
  // pairStrength j√° existe e usa stats (cooc + lift)
  const ps = pairStrength(a,b, sShort);
  const pm = (sMed ? pairStrength(a,b, sMed) : ps);
  return (ps*wShort) + (pm*wMed);
}

function mixGroupStrength(group, sShort, sMed, wShort=0.7, wMed=0.3){
  let sum=0, pairs=0;
  for(let i=0;i<group.length;i++){
    for(let j=i+1;j<group.length;j++){
      sum += mixPairStrength(group[i], group[j], sShort, sMed, wShort, wMed);
      pairs++;
    }
  }
  return { sum, avg: pairs? sum/pairs : 0 };
}

function parityPenalty(line){
  const pares = line.filter(n=>n%2===0).length;
  return (pares===2 || pares===3) ? 0 : 6;
}

function blockPenalty(line){
  const b = distribuicaoBlocos(line);
  const maxBlock = Math.max(b.A,b.B,b.C,b.D,b.E);
  return (maxBlock>=4) ? (maxBlock-3)*10 : 0;
}

function colPenalty(line){
  // colunas 1..5: 1-5,6-10,11-15,16-20,21-25
  const cols=[0,0,0,0,0];
  for(const n of line){
    const c = Math.min(4, Math.floor((n-1)/5));
    cols[c]++;
  }
  const maxCol = Math.max(...cols);
  return (maxCol>=4) ? (maxCol-3)*8 : 0;
}

function lineQualityScore(line, sShort, sMed){
  const st = mixGroupStrength(line, sShort, sMed).sum;
  const pen = parityPenalty(line) + blockPenalty(line) + colPenalty(line);
  return st - pen;
}

function overlapCount(a,b){
  const sb=new Set(b);
  let k=0;
  for(const x of a) if(sb.has(x)) k++;
  return k;
}

function diversifyPenalty(candidateLine, existingLines){
  // penaliza repeti√ß√£o com linhas j√° formadas
  let pen=0;
  for(const l of existingLines){
    pen += overlapCount(candidateLine, l) * 2.0;
  }
  return pen;
}

function buildCombinations(arr, k){
  const res=[];
  const a=arr.slice().sort((x,y)=>x-y);
  const pick=[];
  function bt(start){
    if(pick.length===k){ res.push(pick.slice()); return; }
    for(let i=start;i<a.length;i++){
      pick.push(a[i]); bt(i+1); pick.pop();
    }
  }
  bt(0);
  return res;
}

function bestKFromPool(pool, k, sShort, sMed, existingLines=[], hardExclude=new Set()){
  const arr = pool.filter(n=>!hardExclude.has(n));
  if(arr.length<k) return null;
  const combs = buildCombinations(arr, k);
  let best=null, bestScore=-Infinity;
  for(const g of combs){
    const sc = lineQualityScore(g, sShort, sMed) - diversifyPenalty(g, existingLines);
    if(sc>bestScore){ bestScore=sc; best=g; }
  }
  return best;
}

function bestComplement(quartet, poolNaoSaiu, sShort, sMed, existingLines=[]){
  let best=null, bestScore=-Infinity;
  for(const n of poolNaoSaiu){
    const line = sortNum([...quartet, n]);
    const sc = lineQualityScore(line, sShort, sMed) - diversifyPenalty(line, existingLines);
    if(sc>bestScore){ bestScore=sc; best=n; }
  }
  return best;
}

function countsInConcursos(concursos){
  const cnt=Array(26).fill(0);
  for(const c of concursos){
    for(const n of (c.dezenas||[]).map(toNum)) cnt[n]++;
  }
  return cnt;
}

async function getMediumPayloadFor15P(medN){
  try{
    const p = await getOnlineConcursos(medN);
    p.concursos = p.concursos.slice().sort((a,b)=>a.concurso-b.concurso);
    return p;
  }catch(e){
    return null;
  }
}


async function buildLines15PAdvanced(payloadShort, qtdShort){
  // ‚úÖ NOVO 15P (PADR√ÉO FIXO): o "treino" vira regra permanente.
  // Aqui N√ÉO usamos frequ√™ncia/lift/score para "pontuar passado".
  // Usamos apenas o comportamento na janela N (qtdShort) para CLASSIFICAR (letras)
  // e aplicamos um TEMPLATE FIXO (padr√£o) para montar 5 linhas.

  const conc = (payloadShort.concursos||[]).slice().sort((a,b)=>a.concurso-b.concurso);
  const N = Math.max(3, parseInt(qtdShort||3,10));
  const window = conc.slice(Math.max(0, conc.length - N)); // √∫ltimos N concursos (contexto)
  const ultimo = window[window.length-1];

  const lastSet = new Set(((ultimo?.dezenas)||[]).map(toNum));
  // Presen√ßa por n√∫mero na janela (mais antigo -> mais recente)
  const pres = {};
  for(let n=1;n<=25;n++) pres[n]=Array(window.length).fill(0);
  for(let i=0;i<window.length;i++){
    const set = new Set((window[i].dezenas||[]).map(toNum));
    for(let n=1;n<=25;n++){
      if(set.has(n)) pres[n][i]=1;
    }
  }

  function lastSeenIdx(bits){
    for(let i=bits.length-1;i>=0;i--) if(bits[i]===1) return (bits.length-1-i); // 0 = saiu no √∫ltimo
    return 999;
  }
  function countOn(bits){ return bits.reduce((a,b)=>a+b,0); }

  // ‚úÖ Letras (A‚ÄìH) gerais para qualquer N:
  // - dimens√£o 1: presen√ßa (alta/m√©dia/baixa/zero)
  // - dimens√£o 2: rec√™ncia (saiu no √∫ltimo OU n√£o)
  function letterOf(n){
    const bits = pres[n];
    const c = countOn(bits);
    if(c===0) return "H"; // adormecida total
    const recent = (bits[bits.length-1]===1);

    // cortes proporcionais ao tamanho da janela
    const high = Math.ceil(bits.length*0.75);  // muito presente
    const med  = Math.ceil(bits.length*0.50);  // presen√ßa m√©dia
    const low  = 1;                            // presen√ßa baixa (>=1)

    if(c>=high) return recent ? "A" : "B";
    if(c>=med)  return recent ? "C" : "D";
    // c >= low
    // distingue "pulso" vs "atrasada"
    const ls = lastSeenIdx(bits);
    if(recent) return "E";
    if(ls<=2)  return "F"; // apareceu recentemente mas n√£o no √∫ltimo
    return "G";            // apareceu pouco e est√° mais atrasada
  }

  // Perfil alvo (extra√≠do do treino 3592‚Äì3612, e FIXO):
  // 15 sorteadas (3 linhas): mistura de quentes/m√©dias/baixas/1-2 adormecidas.
  const target15 = { hot:2, med:6, low:5, zero:2 }; // soma 15
  // 10 "fora" (2 linhas): tamb√©m mistura (n√£o s√≥ frias), mas evita repetir a estrutura das 3 primeiras.

  function bucket(letter){
    if(letter==="A"||letter==="B") return "hot";
    if(letter==="C"||letter==="D") return "med";
    if(letter==="E"||letter==="F"||letter==="G") return "low";
    return "zero"; // H
  }

  // ranking simples (n√£o √© "pontua√ß√£o por passado"; √© desempate estrutural)
  function attrs(n){
    const band = Math.floor((n-1)/5); // 0..4 (linhas 1..5)
    const col  = (n-1)%5;            // 0..4 (colunas)
    const isPrime = [2,3,5,7,11,13,17,19,23].includes(n);
    const isEven = (n%2===0);
    return {band,col,isPrime,isEven};
  }

  const nums = [];
  for(let n=1;n<=25;n++){
    const L = letterOf(n);
    const b = bucket(L);
    const a = attrs(n);
    nums.push({n, L, b, ...a});
  }

  // Escolhe o "band" (linha 1..5) mais forte para ser a LINHA PESADA (padr√£o do treino)
  const bandScore = Array(5).fill(0);
  for(const x of nums){
    // peso por bucket (s√≥ para escolher a regi√£o)
    const w = (x.b==="hot")?3 : (x.b==="med")?2 : (x.b==="low")?1 : 0.5;
    bandScore[x.band] += w;
  }
  let heavyBand = 0;
  for(let i=1;i<5;i++) if(bandScore[i]>bandScore[heavyBand]) heavyBand=i;

  // helper: seleciona n√∫meros por bucket com filtros
  function pickFrom(filterFn, k, preferFn){
    const pool = nums.filter(filterFn);
    pool.sort((a,b)=>{
      // preferFn maior primeiro
      const pa = preferFn?preferFn(a):0;
      const pb = preferFn?preferFn(b):0;
      if(pb!==pa) return pb-pa;
      return a.n-b.n;
    });
    return pool.slice(0,k).map(x=>x.n);
  }

  // Sele√ß√£o base das 15 "prov√°veis" seguindo a mistura fixa
  const chosen = new Set();

  function addMany(arr){ arr.forEach(n=>chosen.add(n)); }
  function remaining(filterFn){ return nums.filter(x=>!chosen.has(x.n) && filterFn(x)); }

  // üîπ 1) hot
  addMany(pickFrom(x=>x.b==="hot", target15.hot, (x)=> (x.band===heavyBand?2:0) + (x.L==="A"?1:0)));
  // üîπ 2) med
  addMany(pickFrom(x=>x.b==="med", target15.med, (x)=> (x.band===heavyBand?1:0) + (x.L==="C"?1:0)));
  // üîπ 3) low
  addMany(pickFrom(x=>x.b==="low", target15.low, (x)=> (x.band===heavyBand?0.5:0) + (x.L==="E"?1:0)));
  // üîπ 4) zero (H)
  addMany(pickFrom(x=>x.b==="zero", target15.zero, (x)=> (x.band===heavyBand?0.2:0)));

  // Se faltou (por qualquer motivo), completa com o que sobrar na ordem hot->med->low->zero
  while(chosen.size<15){
    const next = remaining(x=>true).sort((a,b)=>{
      const order = {hot:0,med:1,low:2,zero:3};
      if(order[a.b]!==order[b.b]) return order[a.b]-order[b.b];
      return a.n-b.n;
    })[0];
    if(!next) break;
    chosen.add(next.n);
  }

  let chosen15Final = sortNum([...chosen]).slice(0,15);
  // ‚úÖ Alias de compatibilidade: algumas rotinas usam chosen15
const chosen15 = Array.isArray(chosen15Final) ? chosen15Final : [];

  // ‚úÖ Ajuste preditivo: evitar "copiar" o √∫ltimo concurso.
  // Mantemos algumas repetidas (natural), mas LIMITAMOS excesso para n√£o gerar linha id√™ntica ao √∫ltimo sorteio.
  const ultimoSet = new Set((ultimo?.dezenas||[]).map(toNum));
  function overlapCount(arr, setRef){
    let c=0; for(const n of arr) if(setRef.has(n)) c++;
    return c;
  }
  const MAX_REPETIDAS_15 = 6;     // total de repetidas (entre as 15 escolhidas) vs √∫ltimo concurso
  const MAX_REPETIDAS_LINHA = 2;  // repetidas por linha (FORTE) vs √∫ltimo concurso

  function rebalanceAgainstLast(list15){
    let cur = list15.slice();
    let ov = overlapCount(cur, ultimoSet);
    if(ov <= MAX_REPETIDAS_15) return cur;

    // Candidatos fora do √∫ltimo concurso (prioriza buckets hot->med->low->zero)
    const order = {hot:0,med:1,low:2,zero:3};
    const outside = nums
      .filter(x=>!ultimoSet.has(x.n))
      .sort((a,b)=>{
        if(order[a.b]!==order[b.b]) return order[a.b]-order[b.b];
        const pref = (x)=> (x.band===heavyBand?1:0) + (["B","D","F","G"].includes(x.L)?0.5:0);
        const pa=pref(a), pb=pref(b);
        if(pb!==pa) return pb-pa;
        return a.n-b.n;
      })
      .map(x=>x.n);

    while(ov > MAX_REPETIDAS_15){
      let removeIdx = -1;
      let replacement = null;

      // remove uma repetida e tenta repor por um n√∫mero fora do √∫ltimo (idealmente do mesmo bucket)
      for(let i=0;i<cur.length;i++){
        const n = cur[i];
        if(!ultimoSet.has(n)) continue;
        const bn = bucket(letterOf(n));
        const sameBucket = outside.find(x=>!cur.includes(x) && bucket(letterOf(x))===bn);
        const any = outside.find(x=>!cur.includes(x));
        replacement = sameBucket || any;
        removeIdx = i;
        if(replacement!=null) break;
      }
      if(removeIdx===-1 || replacement==null) break;

      cur[removeIdx] = replacement;
      cur = sortNum(cur).slice(0,15);
      ov = overlapCount(cur, ultimoSet);
    }
    return cur;
  }

  chosen15Final = rebalanceAgainstLast(chosen15Final);

  // Agora, montar as 5 linhas:
  // - Linha 1 (pesada): 4 ou 5 da heavyBand
  // - Linhas 2 e 3: completar com sequ√™ncia 4-5 e equil√≠brio de paridade
  // - Linhas 4 e 5: usar as 10 restantes, quebrando estrutura e evitando concentra√ß√£o

  function balanceParity(line, pool){
    // tenta manter 2/3 pares ou 3/2
    const ev = line.filter(n=>n%2===0).length;
    if(ev===0 || ev===5){
      // troca 1 n√∫mero por outro de paridade oposta se poss√≠vel
      const wantEven = ev===0;
      for(let i=0;i<line.length;i++){
        const cur = line[i];
        const repl = pool.find(n=> (n%2===0)===wantEven && !line.includes(n));
        if(repl){
          line[i]=repl;
          return sortNum(line);
        }
      }
    }
    return sortNum(line);
  }

  const chosenMeta = chosen15Final.map(n=>{
    const x = nums.find(z=>z.n===n);
    return x;
  });

  const inBand = chosenMeta.filter(x=>x.band===heavyBand).map(x=>x.n);
  const outBand = chosenMeta.filter(x=>x.band!==heavyBand).map(x=>x.n);

  // Linha 1: pega at√© 5 do heavyBand, completa se faltar
  let L1 = sortNum(inBand.slice(0,5));
  if(L1.length<5){
    const need = 5-L1.length;
    L1 = sortNum([...L1, ...outBand.slice(0,need)]);
  }


  // ‚úÖ Anti-c√≥pia do √∫ltimo concurso (preditivo):
  // Evita linhas (principalmente a Linha 1) virarem "espelho" do √∫ltimo sorteio.
  function overlapCount(line){
    let c=0; for(const n of line){ if(lastSet.has(n)) c++; } return c;
  }
  function reduceOverlap(line, maxOverlap){
    let cur = line.slice();
    let ov = overlapCount(cur);
    if(ov<=maxOverlap) return sortNum(cur);

    // candidatos para troca: prioriza dezenas escolhidas (das 15) que N√ÉO sa√≠ram no √∫ltimo
    const cand = chosen15.filter(n=>!cur.includes(n) && !lastSet.has(n)).sort((a,b)=>a-b);
    if(!cand.length) return sortNum(cur);

    // troca os que est√£o no √∫ltimo, come√ßando pelos mais "colados" (sequ√™ncias) e depois pelos maiores
    const toSwapIdx = cur
      .map((n,i)=>({n,i}))
      .filter(x=>lastSet.has(x.n))
      .sort((a,b)=> (b.n-a.n)); // maiores primeiro

    let ci=0;
    for(const item of toSwapIdx){
      if(ov<=maxOverlap || ci>=cand.length) break;
      cur[item.i] = cand[ci++];
      ov = overlapCount(cur);
    }
    return sortNum(cur);
  }

  // Linha 1: max 2 repetidas do √∫ltimo concurso
  L1 = reduceOverlap(L1, 2);

  // Se ainda ficou uma sequ√™ncia exata de 5 totalmente dentro do √∫ltimo (ex.: 16-20),
  // for√ßa quebra trocando 1 n√∫mero por outro fora do √∫ltimo.
  if(overlapCount(L1)>=4){
    // tenta quebrar no meio da sequ√™ncia
    const candBreak = chosen15.filter(n=>!L1.includes(n) && !lastSet.has(n)).sort((a,b)=>a-b);
    if(candBreak.length){
      L1[2] = candBreak[0];
      L1 = sortNum(L1);
    }
  }
  // ‚úÖ Evita linha 1 id√™ntica ao √∫ltimo concurso: limita repetidas e troca por alternativas
  function fixLineAgainstLast(line, poolPreferred){
    let ln = line.slice();
    // se veio "copiada" (4+ repetidas), substitui por n√∫meros fora do √∫ltimo
    while(overlapCount(ln, ultimoSet) > MAX_REPETIDAS_LINHA){
      // troca um n√∫mero repetido por outro fora do √∫ltimo (preferindo mesma band)
      let changed = false;
      for(let i=0;i<ln.length;i++){
        const n = ln[i];
        if(!ultimoSet.has(n)) continue;
        // tenta reposi√ß√£o fora do √∫ltimo e n√£o usada
        const repl = (poolPreferred||[]).find(x=>!ln.includes(x) && !ultimoSet.has(x))
                  || nums.map(z=>z.n).find(x=>!ln.includes(x) && !ultimoSet.has(x));
        if(repl!=null){
          ln[i]=repl;
          ln = sortNum(ln).slice(0,5);
          changed = true;
          break;
        }
      }
      if(!changed) break;
    }
    return sortNum(ln).slice(0,5);
  }
  // pool preferido: ainda tenta manter a regi√£o pesada, mas fora do √∫ltimo
  const preferPool = nums.filter(x=>x.band===heavyBand).map(x=>x.n).concat(outBand);
  L1 = fixLineAgainstLast(L1, preferPool);

  // Remove usados de chosen15
  const used = new Set(L1);

  // tenta achar a maior sequ√™ncia dentro dos restantes para estruturar L2/L3
  const rest = chosen15Final.filter(n=>!used.has(n)).sort((a,b)=>a-b);
  function longestRun(arr){
    let best=[], cur=[];
    for(let i=0;i<arr.length;i++){
      if(i===0 || arr[i]===arr[i-1]+1) cur.push(arr[i]);
      else { if(cur.length>best.length) best=cur.slice(); cur=[arr[i]]; }
    }
    if(cur.length>best.length) best=cur.slice();
    return best;
  }
  const run = longestRun(rest);

  // Linha 2: pega 3-4 da sequ√™ncia (se existir), completa com restantes
  let L2 = [];
  if(run.length>=4){
    L2 = run.slice(0,4);
  }else if(run.length>=3){
    L2 = run.slice(0,3);
  }
  L2.forEach(n=>used.add(n));
  const rest2 = chosen15Final.filter(n=>!used.has(n)).sort((a,b)=>a-b);
  while(L2.length<5 && rest2.length){
    const n = rest2.shift();
    L2.push(n); used.add(n);
  }
  L2 = balanceParity(sortNum(L2), chosen15Final);

  // Linha 3: completa com o que sobrou das 15
  const rest3 = chosen15Final.filter(n=>!used.has(n)).sort((a,b)=>a-b);
  let L3 = rest3.slice(0,5);
  L3.forEach(n=>used.add(n));
  L3 = balanceParity(sortNum(L3), chosen15Final);

  // Agora as 10 restantes (fora das 15 escolhidas)
  const remaining10 = [];
  for(let n=1;n<=25;n++) if(!chosen.has(n)) remaining10.push(n);

  // Quebra de estrutura: evitar heavyBand concentrado e quebrar sequ√™ncias longas
  const remMeta = remaining10.map(n=>nums.find(z=>z.n===n));

  // Linha 4: mistura (2 hot/med se existirem + 3 low/zero), evitando heavyBand
  const remHotMed = remMeta.filter(x=>x.b==="hot"||x.b==="med").filter(x=>x.band!==heavyBand).map(x=>x.n);
  const remLowZ   = remMeta.filter(x=>x.b==="low"||x.b==="zero").map(x=>x.n);

  let L4 = sortNum([...remHotMed.slice(0,2), ...remLowZ.slice(0,3)]);
  // se n√£o deu 5, completa do restante
  const remAll = remaining10.filter(n=>!L4.includes(n));
  while(L4.length<5 && remAll.length) L4.push(remAll.shift());
  L4 = balanceParity(sortNum(L4), remaining10);

  // Linha 5: o resto dos 10
  let L5 = sortNum(remaining10.filter(n=>!L4.includes(n))).slice(0,5);
  L5 = balanceParity(sortNum(L5), remaining10);

  const finalLines = [L1,L2,L3,L4,L5].map(l=>sortNum(l).slice(0,5));

  // resumo de letras (para o texto de explica√ß√£o)
  const lettersMap = {};
  for(let n=1;n<=25;n++) lettersMap[n]=letterOf(n);

  return { lines: finalLines, lettersMap, heavyBand: heavyBand+1, ultimoConcurso: ultimo?.concurso };
}

function combos3de5(){
  const r=[];
  for(let a=1;a<=3;a++){
    for(let b=a+1;b<=4;b++){
      for(let c=b+1;c<=5;c++){
        r.push([a,b,c]);
      }
    }
  }
  return r;
}
function gerarJogos15P(linhas){
  const comb = combos3de5();
  return comb.map((idxs)=>{
    const set = new Set();
    idxs.forEach(i=> linhas[i-1].forEach(n=>set.add(n)) );
    return sortNum([...set]);
  });
}

function renderBallsInline(nums){
  return nums.map(n=>`<div class="ball">${format2(n)}</div>`).join("");
}

// ‚úÖ Conta quantas vezes um grupo (2..5 dezenas) apareceu inteiro no mesmo concurso
function countGroupTogether(group, concursos){
  const gset = new Set(group.map(Number));
  let count = 0;
  for(const c of concursos){
    const setC = new Set((c.dezenas||[]).map(toNum));
    let ok = true;
    for(const n of gset){
      if(!setC.has(n)){ ok = false; break; }
    }
    if(ok) count++;
  }
  return count;
}

// ‚úÖ Acha o melhor subgrupo de tamanho k dentro da linha (maior ‚Äújuntos‚Äù)
function bestSubgroupTogether(line, k, concursos){
  const arr = line.slice().map(Number).sort((a,b)=>a-b);

  const comb = [];
  function backtrack(start, pick){
    if(pick.length === k){ comb.push(pick.slice()); return; }
    for(let i=start;i<arr.length;i++){
      pick.push(arr[i]);
      backtrack(i+1, pick);
      pick.pop();
    }
  }
  backtrack(0, []);

  let best = { group:null, count:-1 };
  for(const g of comb){
    const ct = countGroupTogether(g, concursos);
    if(ct > best.count){
      best = { group:g, count:ct };
    }
  }
  return best;
}

function maxRunSorted(arr){
  if(!arr.length) return 0;
  let best=1, cur=1;
  for(let i=1;i<arr.length;i++){
    if(arr[i]===arr[i-1]+1){ cur++; best=Math.max(best,cur); }
    else cur=1;
  }
  return best;
}
function primesCount(arr){
  const primes = new Set([2,3,5,7,11,13,17,19,23]);
  let c=0; for(const n of arr) if(primes.has(n)) c++;
  return c;
}
function bandCounts(arr){
  const counts = Array(5).fill(0);
  for(const n of arr){
    const b = Math.floor((n-1)/5); // 0..4
    counts[b]++;
  }
  return counts;
}
function majorityBand(arr){
  const bc = bandCounts(arr);
  let best=0;
  for(let i=1;i<5;i++) if(bc[i]>bc[best]) best=i;
  return best+1; // 1..5
}
function profileBuckets(arr, lettersMap){
  const buckets = {hot:0, med:0, low:0, zero:0};
  const letters = arr.map(n => lettersMap?.[n] || "?");
  for(const L of letters){
    if(L==="A"||L==="B") buckets.hot++;
    else if(L==="C"||L==="D") buckets.med++;
    else if(L==="E"||L==="F"||L==="G") buckets.low++;
    else if(L==="H") buckets.zero++;
  }
  return {buckets, letters};
}

function explainLine(lineIdx, line, ctx, kind){
  const arr = line.slice().map(Number).sort((a,b)=>a-b);
  const odd = arr.filter(n=>n%2===1).length;
  const even = 5 - odd;
  const primes = primesCount(arr);
  const maxRun = maxRunSorted(arr);
  const band = majorityBand(arr);
  const heavyBand = ctx?.heavyBand || null;

  const {buckets, letters} = profileBuckets(arr, ctx?.lettersMap || {});
  const lettersTxt = letters.join(" ");
  const bucketTxt = `Quentes(A/B): <b>${buckets.hot}</b> ‚Ä¢ M√©dias(C/D): <b>${buckets.med}</b> ‚Ä¢ Baixas(E/F/G): <b>${buckets.low}</b> ‚Ä¢ Adormecidas(H): <b>${buckets.zero}</b>`;

  const estrut = [];
  if(maxRun>=4) estrut.push(`sequ√™ncia <b>${maxRun}</b>`);
  else estrut.push(`sequ√™ncia <b>${maxRun}</b>`);
  estrut.push(`paridade <b>${odd}I/${even}P</b>`);
  estrut.push(`primos <b>${primes}</b>`);
  estrut.push(`linha-base <b>${band}</b>${heavyBand===band ? " (pesada)" : ""}`);

  const resumo = (kind==="forte")
    ? `Linha constru√≠da pelo <b>PADR√ÉO FIXO</b>: mistura de comportamentos (letras A‚ÄìH) t√≠pica antes de concursos fortes, com foco em <b>estrutura</b> (linha pesada/seq/paridade/primos). <b>N√£o</b> usa frequ√™ncia, rec√™ncia ou ‚Äúpontua√ß√£o‚Äù do passado para escolher dezenas.`
    : `Linha de <b>contrapadr√£o</b>: perfil t√≠pico de dezenas que <b>podem ficar fora</b>. Mistura m√©dias e quentes tamb√©m, pois ‚Äúestar quente‚Äù n√£o garante sorteio. Essa linha existe para completar o m√©todo 15P (3 linhas entre 5).`;

  const tag = (kind==="forte") ? "üî•" : "üßä";
  const title = `${tag} Linha ${lineIdx} (${kind==="forte" ? "FORTE" : "DIVERSA"})`;

  return `
    <div class="box">
      <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
        <b>${title}</b>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <span class="chip" style="padding:7px 10px;font-size:12px">Letras: <b>${lettersTxt}</b></span>
          <span class="chip" style="padding:7px 10px;font-size:12px">${estrut.join(" ‚Ä¢ ")}</span>
        </div>
      </div>

      <div class="numbers" style="justify-content:flex-start;margin-top:10px">${renderBallsInline(arr)}</div>

      <div class="mini"><b>Por que se juntaram:</b> ${resumo}</div>

      <div class="mini" style="margin-top:10px">
        <b>üìå Resumo comportamental (letras A‚ÄìH):</b><br/>
        ${bucketTxt}<br/>
        <div style="margin-top:8px"><b>Estrutura aplicada:</b> ${estrut.join(" ‚Ä¢ ")}</div>
      </div>
    </div>
  `;
}

/* ===== EDITOR MANUAL 15P ===== */
function initUserLines15FromSystem(lines){
  linesSystem15 = lines.map(l=>l.slice());
  linesUser15 = lines.map(l=>l.slice());
  linesUser15[4] = [];   // ‚úÖ Linha 5 em branco
  activeLine15 = 4;
}

function setActiveLine15(i){ activeLine15=i; render15Editor(); }

function usedNumbersExceptLine(lineIdx){
  const used = new Set();
  for(let i=0;i<5;i++){
    if(i===lineIdx) continue;
    (linesUser15?.[i]||[]).forEach(n=>used.add(n));
  }
  return used;
}

function render15Editor(){
  const root = document.getElementById("editor15Area");
  if(!root || !linesUser15) return;

  const lineBtns = [1,2,3,4,5].map(i=>{
    return `<button class="lineBtn ${activeLine15===i-1?"on":""}" type="button" onclick="setActiveLine15(${i-1})">Linha ${i}</button>`;
  }).join("");

  const current = linesUser15[activeLine15] || [];
  const used = usedNumbersExceptLine(activeLine15);

  root.innerHTML = `
    <div class="box" style="margin-top:12px">
      <b>üß© Monte suas linhas (15P) ‚Äî manual</b>
      <div class="mini" style="margin-top:6px">
        Selecione uma linha e complete com <b>5 dezenas</b>. N√£o permitimos repeti√ß√£o entre linhas (mant√©m a l√≥gica dos 10 jogos).
      </div>

      <div class="lineTabs">${lineBtns}</div>

      <div class="mini" style="margin-top:10px"><b>Linha ${activeLine15+1}:</b></div>
      <div class="slotRow">
        ${[0,1,2,3,4].map(i=>`<div class="slot">${current[i] ? format2(current[i]) : "‚Äî"}</div>`).join("")}
      </div>

      <div class="pickGrid" id="pickGrid15">
        ${[...Array(25)].map((_,i)=>{
          const n=i+1;
          const sel = current.includes(n) ? " sel" : "";
          const lock = used.has(n) ? " lock" : "";
          return `<div class="pickCell${sel}${lock}" data-n="${n}">${format2(n)}</div>`;
        }).join("")}
      </div>

      <div class="row" style="margin-top:12px">
        <div class="col">
          <button class="btn btnGhost" type="button" onclick="linesUser15[activeLine15]=[];render15Editor()">Limpar linha</button>
        </div>
        <div class="col">
          <button class="btn btnPrimary" type="button" onclick="gerar15PComMinhasLinhas()">Gerar 10 jogos (minhas linhas)</button>
        </div>
      </div>

      <div class="row" style="margin-top:10px">
        <div class="col">
          <button class="btn btnGhost" type="button" onclick="initUserLines15FromSystem(linesSystem15);render15Editor();document.getElementById('user15Output').innerHTML=''">Resetar para linhas do sistema</button>
        </div>
        <div class="col">
          <button class="btn btnGhost" type="button" onclick="goView('view15p')">Ok</button>
        </div>
      </div>

      <div class="mini" style="margin-top:10px">
        Dica PRIME: em cada linha, tente manter <b>2/3 pares</b>, mix de frequ√™ncia e evitar 4+ no mesmo bloco.
      </div>
    </div>
  `;

  bindPickGrid("pickGrid15", (n)=>{
    if(used.has(n)) return;
    const line = linesUser15[activeLine15];
    const idx = line.indexOf(n);
    if(idx>=0) line.splice(idx,1);
    else{
      if(line.length>=5) return alert("Essa linha j√° tem 5 dezenas.");
      line.push(n); line.sort((a,b)=>a-b);
    }
    render15Editor();
  });
}

function allLinesComplete(lines){
  return lines && lines.length===5 && lines.every(l=>Array.isArray(l) && l.length===5);
}

function gerar15PComMinhasLinhas(){
  if(!allLinesComplete(linesUser15)){
    return alert("Complete as 5 linhas com 5 dezenas cada.");
  }

  // ‚úÖ Torna o MANUAL a refer√™ncia ativa do 15P (sobrep√µe o autom√°tico)
  linesSystem15 = linesUser15.map(l=>l.slice());

  const jogos = gerarJogos15P(linesSystem15);

  const jogosHtml = jogos.map((j, idx)=>`
    <div class="box">
      <b>Jogo ${idx+1}</b>
      <div class="numbers" style="justify-content:flex-start;margin-top:10px">${renderBallsInline(j)}</div>
    </div>
  `).join("");

  const linesTable = linesSystem15.map((l,idx)=>`
    <tr>
      <td><b>${idx+1}</b></td>
      <td class="mono">${l.map(format2).join(" - ")}</td>
    </tr>
  `).join("");

  // ‚úÖ Se existir uma sa√≠da "manual" antiga, limpa para n√£o duplicar
  const userOut = document.getElementById("user15Output");
  if(userOut) userOut.innerHTML = "";

  // ‚úÖ Procura o box "10 jogos do sistema" e substitui pelo resultado manual
  const p15 = document.getElementById("p15Area") || document;
  const boxes = Array.from(p15.querySelectorAll(".box"));
  const systemGamesBox = boxes.find(b=>{
    const bb = b.querySelector("b");
    return bb && /10 jogos do sistema/i.test(bb.textContent || "");
  });

  const systemLinesBox = boxes.find(b=>{
    const bb = b.querySelector("b");
    return bb && /Linhas 1 a 5/i.test(bb.textContent || "");
  });

  const manualPackHTML = `
    <b>üéØ 10 jogos (MANUAL ‚Äî substituiu o autom√°tico)</b>
    <div class="mini" style="margin-top:10px">
      Voc√™ est√° usando suas <b>5 linhas manuais</b> como base. Este m√©todo cobre todas as combina√ß√µes de 3 linhas entre 5 (10 jogos).
      <b style="text-transform:uppercase">Acertando 3 linhas completas, voc√™ forma 1 dos 10 jogos.</b>
    </div>
    <div class="grid" style="margin-top:12px">${jogosHtml}</div>
  `;

  const manualLinesHTML = `
    <b>üìå Linhas 1 a 5 (MANUAIS ‚Äî ativas)</b>
    <div class="mini" style="margin-top:6px">
      Estas s√£o as linhas que voc√™ montou manualmente e que foram usadas para gerar os 10 jogos abaixo.
    </div>
    <div style="margin-top:12px;overflow:auto">
      <table class="table">
        <thead><tr><th>Linha</th><th>Dezenas</th></tr></thead>
        <tbody>${linesTable}</tbody>
      </table>
    </div>
  `;

  if(systemGamesBox){
    systemGamesBox.innerHTML = manualPackHTML;
  }else{
    // Fallback: se n√£o achar, mostra no user15Output (sem quebrar nada)
    if(userOut){
      userOut.innerHTML = `
        <div class="box" style="margin-top:12px">${manualLinesHTML}</div>
        <div class="box" style="margin-top:12px">${manualPackHTML}</div>
      `;
    }
  }

  // Tamb√©m atualiza o box das linhas, se existir
  if(systemLinesBox){
    systemLinesBox.innerHTML = manualLinesHTML + `
      <div class="row" style="margin-top:10px">
        <div class="col">
          <button class="btn btnBlue" type="button" onclick="render15Editor()">‚úçÔ∏è Editar minhas linhas (manual)</button>
        </div>
        <div class="col">
          <button class="btn btnGhost" type="button" onclick="initUserLines15FromSystem(linesSystem15);render15Editor();">Continuar com estas linhas</button>
        </div>
      </div>
    `;
  }

  alert("‚úÖ Manual substituiu o autom√°tico!");
}


async function gerar15P(){
  const can15p = ((access.premium && access.addon15) || access.isAdmin);
  if(!can15p) return alert("üîí O recurso '15 pontos garantido' √© um EXTRA comprado separadamente (libera via claims).");

  const qtd = qtdSelecionada();
  try{
    await prepararContextoBase(qtd);
    const payload = lastPayload;

    setStatus(true,"15P: analisando e montando 5 linhas‚Ä¶");
    setProgress(82);

    const stats = calcCoocAndStats(payload.concursos);
    stats.concursosRef = payload.concursos; // ‚úÖ usado para calcular 5/4/3/2 juntas

    // ‚úÖ NOVO 15P: linhas por "saiu / n√£o saiu" + regulariza√ß√£o curto+m√©dio + cobertura
    const adv = await buildLines15PAdvanced(payload, qtd);
    let lines = adv.lines;


    const jogos = gerarJogos15P(lines);
    const sourceInfo = { source: payload.source, mode: payload.mode };

    setStatus(false,"");
    setProgress(0);

    initUserLines15FromSystem(lines);

    const explainCtx = { lettersMap: adv.lettersMap || {}, heavyBand: adv.heavyBand || null };

    function maxRunSortedLocal(arr){
      if(!arr.length) return 0;
      let best=1, cur=1;
      for(let i=1;i<arr.length;i++){
        if(arr[i]===arr[i-1]+1){ cur++; best=Math.max(best,cur); } else cur=1;
      }
      return best;
    }
    function primesCountLocal(arr){
      const primes = new Set([2,3,5,7,11,13,17,19,23]);
      let c=0; for(const n of arr) if(primes.has(n)) c++;
      return c;
    }
    function profileShort(line){
      const letters = line.map(n => explainCtx.lettersMap[n] || "?");
      let hot=0, med=0, low=0, zero=0;
      for(const L of letters){
        if(L==="A"||L==="B") hot++;
        else if(L==="C"||L==="D") med++;
        else if(L==="E"||L==="F"||L==="G") low++;
        else if(L==="H") zero++;
      }
      return { letters, hot, med, low, zero };
    }
    function majorityBandLocal(line){
      const bc = [0,0,0,0,0];
      for(const n of line){
        const b = Math.floor((n-1)/5);
        bc[b] += 1;
      }
      let best=0;
      for(let i=1;i<5;i++) if(bc[i]>bc[best]) best=i;
      return best+1;
    }

    const lineMeta = lines.map((l,idx)=> {
      const line = l.slice().map(Number).sort((a,b)=>a-b);
      const odd = line.filter(n=>n%2===1).length;
      const even = 5 - odd;
      const primes = primesCountLocal(line);
      const run = maxRunSortedLocal(line);
      const band = majorityBandLocal(line);
      const p = profileShort(line);
      const struct = [
        `seq ${run}`,
        `${odd}I/${even}P`,
        `primos ${primes}`,
        `linha ${band}${(explainCtx.heavyBand===band) ? " (pesada)" : ""}`
      ];
      return {
        idx: idx+1,
        kind: (idx<3) ? "forte" : "diversa",
        lettersTxt: p.letters.join(" "),
        profileTxt: `AB:${p.hot} CD:${p.med} EFG:${p.low} H:${p.zero}`,
        structureTxt: struct.join(" ‚Ä¢ "),
        line
      };
    });

    const jogosHtml = jogos.map((j, idx)=>{
      return `
        <div class="box">
          <b>Jogo ${idx+1}</b>
          <div class="numbers" style="justify-content:flex-start;margin-top:10px">${renderBallsInline(j)}</div>
        </div>
      `;
    }).join("");

    document.getElementById("p15Area").innerHTML = `
      <div style="display:flex;align-items:flex-start;justify-content:space-between;gap:12px;flex-wrap:wrap">
        <div>
          <div style="font-weight:1000;font-size:16px">‚úÖ 15 Pontos (Estrat√©gia) ‚Ä¢ 10 jogos</div>
          <div class="mini">Janela: <b>${payload.inicio}</b> a <b>${payload.ultimo}</b> (${payload.concursos.length} concursos)</div>
          <div class="mini" style="margin-top:8px">
            üìå Regra do m√©todo: cobrimos todas as combina√ß√µes de <b>3 linhas entre 5</b> (10 jogos).
<b style="text-transform:uppercase">Se voc√™ acertar as 3 linhas completas, voc√™ fecha 1 dos 10 jogos.</b>
          </div>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap">
  <button class="btn btnGhost" type="button" onclick="verConcursos()">üìÖ Ver concursos</button>
  <button class="btn btnBlue" type="button" onclick="salvar15P()">üíæ Salvar 15P</button>
  <button class="btn btnGhost" type="button" onclick="carregar15P()">üìÇ Carregar 15P salvo</button>
</div>
      </div>

      <div class="box" style="margin-top:12px">
        <b>üìå Linhas 1 a 5 (geradas pelo sistema)</b>
        <div class="mini" style="margin-top:6px">
          O sistema usa um <b>PADR√ÉO FIXO</b> aprendido no treino. Em cada gera√ß√£o, ele <b>classifica as dezenas por comportamento (letras A‚ÄìH)</b> na janela escolhida e aplica a estrutura vencedora (linha pesada, sequ√™ncia, paridade e oscila√ß√£o de primos). <b>N√£o</b> usa frequ√™ncia, rec√™ncia ou pontua√ß√£o do passado para escolher dezenas.
        </div>
        <div style="margin-top:12px;overflow:auto">
          <table class="table">
            <thead>
              <tr>
                <th>Linha</th>
                <th>Tipo</th>
                <th>Dezenas</th>
                <th>Letras (A‚ÄìH)</th>
                <th>Perfil</th>
                <th>Estrutura</th>
              </tr>
            </thead>
            <tbody>
              ${lineMeta.map(m=>`
                <tr>
                  <td><b>${m.idx}</b></td>
                  <td>${m.kind==="forte" ? "FORTE" : "DIVERSA"}</td>
                  <td class="mono">${m.line.map(format2).join(" - ")}</td>
                  <td class="mono">${m.lettersTxt}</td>
                  <td class="mono">${m.profileTxt}</td>
                  <td>${m.structureTxt}</td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>

        <div class="row" style="margin-top:10px">
          <div class="col">
            <button class="btn btnBlue" type="button" onclick="render15Editor()">‚úçÔ∏è Criar minhas linhas (manual)</button>
          </div>
          <div class="col">
            <button class="btn btnGhost" type="button" onclick="document.getElementById('user15Output').innerHTML=''">Limpar resultado manual</button>
          </div>
        </div>
      </div>

      <div id="editor15Area"></div>
      <div id="user15Output"></div>

      <div class="box" style="margin-top:12px">
        <b>üîç Explica√ß√£o detalhada das linhas</b>
        <div class="grid" style="margin-top:12px">
          ${explainLine(1, lines[0], explainCtx, "forte")}
          ${explainLine(2, lines[1], explainCtx, "forte")}
          ${explainLine(3, lines[2], explainCtx, "forte")}
          ${explainLine(4, lines[3], explainCtx, "diversa")}
          ${explainLine(5, lines[4], explainCtx, "diversa")}
        </div>
      </div>

      <div class="box" style="margin-top:12px">
        <b>üéØ 10 jogos do sistema</b>
        <div class="grid" style="margin-top:12px">${jogosHtml}</div>
        <div class="mini" style="margin-top:10px">
          Estrat√©gia estat√≠stica com base na janela selecionada. <b>N√£o h√° garantia de acerto</b>.
        </div>
      </div>

      <div class="tinyFoot">Fonte: ${sourceInfo.source || "‚Äî"} ‚Ä¢ Modo: ${String(sourceInfo.mode||"‚Äî").toUpperCase()}</div>
    `;

    goView("view15p");
  }catch(e){
    setStatus(false,""); setProgress(0);
    document.getElementById("p15Area").innerHTML = `
      <div class="box">
        <b>‚ö†Ô∏è Erro</b>
        <div class="mini" style="margin-top:8px">${String(e?.message || e)}</div>
      </div>
    `;
    goView("view15p");
  }
}
</script>

<script>
// ===== JOGOS SALVOS (N√ÉO SOME) =====
const KEY_JOGOS_SALVOS = "lotofacil_jogos_salvos";

let jogosSalvos = [];
// ‚úÖ slot selecionado na tela Jogos Salvos
let selectedSavedSlot = "Principal+Invertida+Tecnica";

try {
  jogosSalvos = JSON.parse(localStorage.getItem(KEY_JOGOS_SALVOS) || "[]");
  if (!Array.isArray(jogosSalvos)) jogosSalvos = [];
} catch (e) {
  jogosSalvos = [];
}

function salvarJogoNoStorage(obj) {
  // se tiver slot, sobrep√µe o mesmo slot
  if (obj && obj.slot) {
    const i = jogosSalvos.findIndex(x => x && x.slot === obj.slot);
    if (i >= 0) jogosSalvos[i] = obj;
    else jogosSalvos.push(obj);
  } else {
    // sem slot, adiciona
    jogosSalvos.push(obj);
  }

  localStorage.setItem(KEY_JOGOS_SALVOS, JSON.stringify(jogosSalvos));
}

function carregarJogosDoStorage() {
  try {
    const arr = JSON.parse(localStorage.getItem(KEY_JOGOS_SALVOS) || "[]");
    jogosSalvos = Array.isArray(arr) ? arr : [];
  } catch (e) {
    jogosSalvos = [];
  }
}
/* =========================
   Eventos
========================= */
document.getElementById("btnEntrar").addEventListener("click", entrar);
document.getElementById("btnForgot").addEventListener("click", forgotPassword);

document.getElementById("btnComprar").addEventListener("click", comprarPremium);
document.getElementById("btnJaComprei").addEventListener("click", jaComprei);
document.getElementById("btnSair").addEventListener("click", sair);

document.getElementById("btnComprar15p").addEventListener("click", comprar15p);
document.getElementById("btnAtivar15p").addEventListener("click", jaComprei15p);

["btnHomePrincipal","btnHomeAnalise","btnHomeInvertida","btnHomeTecnica","btnHome15p","btnHomeSaved"].forEach(id=>{
  const el = document.getElementById(id);
  if(el) bindCardKey(el);
});
/* =========================
   ‚úÖ JOGOS SALVOS + CONFER√äNCIA
========================= */

document.getElementById("btnHomeSaved").onclick = ()=>{
  goView("viewSavedGames");
};

function checkSavedGames(){
  const qtd = Number(document.getElementById("savedCheckQtd").value);

  carregarJogosDoStorage();

  if(!jogosSalvos.length){
    alert("Nenhum jogo salvo ainda.");
    return;
  }

  const item = jogosSalvos.find(x => x && x.slot === selectedSavedSlot) || jogosSalvos[0];
  if(!item){
    alert("Selecione um jogo salvo.");
    return;
  }

  (async ()=>{
    try{
      if(!lastPayload || !lastPayload.concursos){
        const qtdBase = qtdSelecionada();
        await prepararContextoBase(qtdBase);
      }

      const concursos = (lastPayload.concursos || []).slice(-qtd);
      if(!concursos.length){
        alert("N√£o foi poss√≠vel carregar concursos para confer√™ncia.");
        return;
      }

      function hitsCount(gameNums, concursoDezenas){
        const set = new Set((concursoDezenas || []).map(toNum));
        return (gameNums || []).filter(n => set.has(Number(n))).length;
      }

      let html = `
        <div class="box" style="margin-top:10px">
          <b>üìå Conferindo:</b> <b>${item.nome || item.slot}</b>
          <div class="mini" style="margin-top:6px">Base: √∫ltimos <b>${qtd}</b> concursos</div>
        </div>
      `;

      if(item.tipo === "pack" && item.pack){
        const pack = item.pack;

        const principalRef = Array.isArray(pack.principal)
          ? pack.principal.slice().map(Number).sort((a,b)=>a-b)
          : null;

        const jogos = [
          { nome: "üéØ Principal (salvo)", nums: Array.isArray(pack.principal) ? pack.principal : null },
          { nome: "üîÑ Invertida (salva)", nums: Array.isArray(pack.invertida) ? pack.invertida : null },
          { nome: "üèÜ T√©cnica 1 (salva)", nums: Array.isArray(pack.tecnica1) ? pack.tecnica1 : null },
          { nome: "üèÜ T√©cnica 2 (salva)", nums: Array.isArray(pack.tecnica2) ? pack.tecnica2 : null }
        ].filter(x => Array.isArray(x.nums) && x.nums.length);

        if(!jogos.length){
          alert("O pacote salvo n√£o tem jogos v√°lidos.");
          return;
        }

        jogos.forEach(obj=>{
          const jogo = obj.nums.slice().map(Number).sort((a,b)=>a-b);

          let principalLine = "";
          if(obj.nome !== "üéØ Principal (salvo)" && Array.isArray(principalRef) && principalRef.length){
            principalLine = `
              <div class="mini" style="margin-top:6px">
                üéØ <b>Principal:</b> <span class="mono">${principalRef.map(format2).join(" - ")}</span>
              </div>
            `;
          }

          let linhasResultados = "";
          concursos.forEach(c=>{
            const hits = hitsCount(jogo, c.dezenas);
            const cls = (hits >= 11 && hits <= 15) ? `hit-${hits}` : "";
            linhasResultados += `
              <div class="mini ${cls}">
                Concurso <b>${c.concurso}</b> ‚Üí <b>${hits} acertos</b>
              </div>
            `;
          });

          html += `
            <div class="box" style="margin-top:10px">
              <b>${obj.nome}</b>
              ${principalLine}
              <div class="numbers" style="justify-content:flex-start;margin-top:8px">
                ${jogo.map(format2).join(" - ")}
              </div>
              <div style="margin-top:10px">${linhasResultados}</div>
            </div>
          `;
        });
      }
      else if(item.tipo === "15p" && item.payload){
        const jogos = Array.isArray(item.payload.jogosSystem) ? item.payload.jogosSystem : null;

        if(!jogos || !jogos.length){
          alert("Esse 15P salvo n√£o tem os 10 jogos do sistema.");
          return;
        }

        
        // ‚úÖ Mostrar Linhas 1 a 5 do Extra 15P no topo (uma √∫nica vez)
        const lines = Array.isArray(item?.payload?.linesSystem15) ? item.payload.linesSystem15
                    : (Array.isArray(item?.payload?.linesUser15) ? item.payload.linesUser15 : null);

        if(Array.isArray(lines) && lines.length === 5){
          const lineRows = lines.map((l,idx)=>{
            const kind = (idx < 3) ? "FORTE" : "DIVERSA";
            const dezenas = (l||[]).slice().map(Number).sort((a,b)=>a-b).map(format2).join(" - ");
            return `
              <tr>
                <td><b>${idx+1}</b></td>
                <td>${kind}</td>
                <td class="mono">${dezenas}</td>
              </tr>
            `;
          }).join("");

          html += `
            <div class="box" style="margin-top:10px">
              <b>üìå Linhas 1 a 5 (do Extra 15P)</b>
              <div style="margin-top:10px;overflow:auto">
                <table class="table">
                  <thead>
                    <tr>
                      <th>Linha</th>
                      <th>Tipo</th>
                      <th>Dezenas</th>
                    </tr>
                  </thead>
                  <tbody>
                    ${lineRows}
                  </tbody>
                </table>
              </div>
            </div>
          `;
        }
jogos.forEach((jogoNums, idx)=>{
          const jogo = jogoNums.slice().map(Number).sort((a,b)=>a-b);

          let linhasResultados = "";
          concursos.forEach(c=>{
            const hits = hitsCount(jogo, c.dezenas);
            const cls = (hits >= 11 && hits <= 15) ? `hit-${hits}` : "";
            linhasResultados += `
              <div class="mini ${cls}">
                Concurso <b>${c.concurso}</b> ‚Üí <b>${hits} acertos</b>
              </div>
            `;
          });

          html += `
            <div class="box" style="margin-top:10px">
              <b>‚úÖ 15P ‚Ä¢ Jogo ${idx+1}</b>
              <div class="numbers" style="justify-content:flex-start;margin-top:8px">
                ${jogo.map(format2).join(" - ")}
              </div>
              <div style="margin-top:10px">${linhasResultados}</div>
            </div>
          `;
        });
      }
      else{
        alert("Tipo de jogo salvo n√£o reconhecido.");
        return;
      }

      document.getElementById("savedGamesResult").innerHTML = html;

    }catch(e){
      console.log(e);
      alert("Erro ao conferir jogos salvos: " + (e?.message || e));
    }
  })();
}
function renderJogosSalvosAoAbrir(){
  // garante que jogosSalvos est√° atualizado
  carregarJogosDoStorage();

  const box = document.getElementById("savedPacksList");
  if(!box) return;

  // se n√£o existe lista ou est√° vazia
  if(!Array.isArray(jogosSalvos) || !jogosSalvos.length){
    box.innerHTML = '<div class="mini">Nenhum jogo salvo ainda.</div>';
    return;
  }

  // ordena do mais recente para o mais antigo (se tiver "at")
  const sorted = [...jogosSalvos].sort((a,b)=>{
    const ta = a?.at ? new Date(a.at).getTime() : 0;
    const tb = b?.at ? new Date(b.at).getTime() : 0;
    return tb - ta;
  });

  let html = "";
  sorted.forEach(item=>{
    const isOn = (item.slot === selectedSavedSlot);

    html += `
      <div class="box savedPack ${isOn ? "on" : ""}" style="margin-top:10px;cursor:pointer;border:1px solid ${isOn ? "rgba(250,204,21,.75)" : "rgba(255,255,255,.22)"};background:${isOn ? "rgba(250,204,21,.18)" : "rgba(255,255,255,.03)"};color:${isOn ? "#0b0b0b" : "#ffffff"}"
        onclick="selectedSavedSlot='${item.slot}'; renderJogosSalvosAoAbrir();">
        <b>üíæ ${item.nome || item.slot}</b><br/>
        <span class="mini">Salvo em: ${item.at ? new Date(item.at).toLocaleString("pt-BR") : "-"}</span>
        <div class="mini" style="margin-top:6px">${isOn ? "‚úÖ Selecionado para confer√™ncia" : "Toque para selecionar"}</div>
      </div>
    `;
  });

  box.innerHTML = html;
}

</script>

</body>
</html>
